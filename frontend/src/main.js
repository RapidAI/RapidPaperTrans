/**
 * LaTeX ç¿»è¯‘å™¨å‰ç«¯äº¤äº’é€»è¾‘
 * 
 * å®ç°åŠŸèƒ½ï¼š
 * - è¾“å…¥è¡¨å•å¤„ç†ï¼ˆURL/ID/æ–‡ä»¶é€‰æ‹©ï¼‰
 * - ä¸åç«¯çš„ Wails ç»‘å®šè°ƒç”¨
 * - çŠ¶æ€æ˜¾ç¤ºæ›´æ–°
 * - PDF åŠ è½½æ˜¾ç¤º
 * 
 * Validates: Requirements 4.5
 */

import './style.css';
import './app.css';

// Wails runtime for file dialogs and events
import { EventsOn } from '../wailsjs/runtime/runtime.js';

// Error Management module
import { initErrorManagement } from './errors.js';

// Backend bindings - these will be generated by Wails
// We need to handle the case where they might not exist yet
let ProcessSource, ProcessSourceWithForce, CheckExistingTranslation, GetStatus, CancelProcess, GetSettings, SaveSettings, TestAPIConnection, OpenFileDialog, OpenDirectoryDialog, GetLastInput, SaveLastInput, GetPDFDataURL, DownloadChinesePDF, DownloadBilingualPDF, DownloadLatexZip, OpenURLInBrowser, CheckStartupRequirements, GetLaTeXDownloadURL;

// PDF Translation bindings
let OpenPDFFileDialog, LoadPDF, TranslatePDF, GetPDFStatus, CancelPDFTranslation, GetTranslatedPDFPath;

// Results Management bindings
let ListTranslatedPapers, DeleteTranslatedPaper, RetranslateFromArxiv, OpenPaperResult, ContinueTranslation;

// GitHub Share bindings
let CheckShareStatus, ShareToGitHub, TestGitHubConnection, CheckShareStatusForPaper, SharePaperToGitHub;

// GitHub Search bindings
let SearchGitHubTranslation, DownloadGitHubTranslation, ListRecentGitHubTranslations, GetArxivPaperMetadata, UpdateGitHubToken;

// Error Management bindings
let ListErrors, RetryFromError, ClearError, ClearAllErrors, ExportErrorsToFile, ExportErrorIDsToFile;

// Try to import the backend bindings
async function initBindings() {
    try {
        // Dynamic import to handle case where bindings don't exist yet
        const App = await import('../wailsjs/go/main/App.js');
        ProcessSource = App.ProcessSource;
        ProcessSourceWithForce = App.ProcessSourceWithForce;
        CheckExistingTranslation = App.CheckExistingTranslation;
        GetStatus = App.GetStatus;
        CancelProcess = App.CancelProcess;
        GetSettings = App.GetSettings;
        SaveSettings = App.SaveSettings;
        TestAPIConnection = App.TestAPIConnection;
        OpenFileDialog = App.OpenFileDialog;
        OpenDirectoryDialog = App.OpenDirectoryDialog;
        GetLastInput = App.GetLastInput;
        SaveLastInput = App.SaveLastInput;
        GetPDFDataURL = App.GetPDFDataURL;
        DownloadChinesePDF = App.DownloadChinesePDF;
        DownloadBilingualPDF = App.DownloadBilingualPDF;
        DownloadLatexZip = App.DownloadLatexZip;
        OpenURLInBrowser = App.OpenURLInBrowser;
        CheckStartupRequirements = App.CheckStartupRequirements;
        GetLaTeXDownloadURL = App.GetLaTeXDownloadURL;
        // PDF Translation bindings
        OpenPDFFileDialog = App.OpenPDFFileDialog;
        LoadPDF = App.LoadPDF;
        TranslatePDF = App.TranslatePDF;
        GetPDFStatus = App.GetPDFStatus;
        CancelPDFTranslation = App.CancelPDFTranslation;
        GetTranslatedPDFPath = App.GetTranslatedPDFPath;
        // Results Management bindings
        ListTranslatedPapers = App.ListTranslatedPapers;
        DeleteTranslatedPaper = App.DeleteTranslatedPaper;
        RetranslateFromArxiv = App.RetranslateFromArxiv;
        OpenPaperResult = App.OpenPaperResult;
        ContinueTranslation = App.ContinueTranslation;
        // GitHub Share bindings
        CheckShareStatus = App.CheckShareStatus;
        ShareToGitHub = App.ShareToGitHub;
        TestGitHubConnection = App.TestGitHubConnection;
        CheckShareStatusForPaper = App.CheckShareStatusForPaper;
        SharePaperToGitHub = App.SharePaperToGitHub;
        // GitHub Search bindings
        SearchGitHubTranslation = App.SearchGitHubTranslation;
        DownloadGitHubTranslation = App.DownloadGitHubTranslation;
        ListRecentGitHubTranslations = App.ListRecentGitHubTranslations;
        GetArxivPaperMetadata = App.GetArxivPaperMetadata;
        UpdateGitHubToken = App.UpdateGitHubToken;
        // Error Management bindings
        ListErrors = App.ListErrors;
        RetryFromError = App.RetryFromError;
        ClearError = App.ClearError;
        ClearAllErrors = App.ClearAllErrors;
        ExportErrorsToFile = App.ExportErrorsToFile;
        ExportErrorIDsToFile = App.ExportErrorIDsToFile;
        return true;
    } catch (error) {
        console.warn('Backend bindings not available yet:', error);
        // Create mock functions for development
        ProcessSource = async (input) => {
            console.log('Mock ProcessSource called with:', input);
            return { original_pdf_path: '', translated_pdf_path: '' };
        };
        GetStatus = async () => {
            return { phase: 'idle', progress: 0, message: '', error: '' };
        };
        CancelProcess = async () => {
            console.log('Mock CancelProcess called');
        };
        GetSettings = async () => {
            return {
                openai_api_key: '',
                openai_base_url: 'https://api.openai.com/v1',
                openai_model: 'gpt-4',
                context_window: 8192,
                default_compiler: 'pdflatex',
                work_directory: ''
            };
        };
        SaveSettings = async (apiKey, baseUrl, model, contextWindow, compiler, workDir) => {
            console.log('Mock SaveSettings called');
        };
        TestAPIConnection = async (apiKey, baseUrl, model) => {
            console.log('Mock TestAPIConnection called');
            return null;
        };
        OpenFileDialog = async () => {
            console.log('Mock OpenFileDialog called');
            return '';
        };
        OpenDirectoryDialog = async () => {
            console.log('Mock OpenDirectoryDialog called');
            return '';
        };
        GetLastInput = async () => {
            console.log('Mock GetLastInput called');
            return '';
        };
        SaveLastInput = async (input) => {
            console.log('Mock SaveLastInput called with:', input);
        };
        GetPDFDataURL = async (path) => {
            console.log('Mock GetPDFDataURL called with:', path);
            return '';
        };
        CheckStartupRequirements = async () => {
            console.log('Mock CheckStartupRequirements called');
            return { latex_installed: true, latex_version: 'Mock', llm_configured: true, llm_error: '' };
        };
        GetLaTeXDownloadURL = async () => {
            console.log('Mock GetLaTeXDownloadURL called');
            return 'https://miktex.org/download';
        };
        // Mock PDF Translation functions
        OpenPDFFileDialog = async () => {
            console.log('Mock OpenPDFFileDialog called');
            return '';
        };
        LoadPDF = async (filePath) => {
            console.log('Mock LoadPDF called with:', filePath);
            return { file_path: filePath, file_name: 'test.pdf', page_count: 10, file_size: 1024000, is_text_pdf: true };
        };
        TranslatePDF = async () => {
            console.log('Mock TranslatePDF called');
            return { original_pdf_path: '', translated_pdf_path: '', total_blocks: 0, translated_blocks: 0 };
        };
        GetPDFStatus = async () => {
            return { phase: 'idle', progress: 0, message: '', total_blocks: 0, completed_blocks: 0, error: '' };
        };
        CancelPDFTranslation = async () => {
            console.log('Mock CancelPDFTranslation called');
        };
        GetTranslatedPDFPath = async () => {
            console.log('Mock GetTranslatedPDFPath called');
            return '';
        };
        // Mock GitHub Search functions
        SearchGitHubTranslation = async (arxivId) => {
            console.log('Mock SearchGitHubTranslation called with:', arxivId);
            return { found: false };
        };
        DownloadGitHubTranslation = async (arxivId, fileType, saveDir) => {
            console.log('Mock DownloadGitHubTranslation called');
            return '';
        };
        ListRecentGitHubTranslations = async (maxCount) => {
            console.log('Mock ListRecentGitHubTranslations called with:', maxCount);
            return [];
        };
        GetArxivPaperMetadata = async (arxivId) => {
            console.log('Mock GetArxivPaperMetadata called with:', arxivId);
            return { arxiv_id: arxivId, title: 'Mock Title', abstract: 'Mock abstract', authors: 'Mock Authors' };
        };
        UpdateGitHubToken = async () => {
            console.log('Mock UpdateGitHubToken called');
            return null;
        };
        // Mock Error Management functions
        ListErrors = async () => {
            console.log('Mock ListErrors called');
            return [];
        };
        RetryFromError = async (id) => {
            console.log('Mock RetryFromError called with:', id);
            return { original_pdf_path: '', translated_pdf_path: '' };
        };
        ClearError = async (id) => {
            console.log('Mock ClearError called with:', id);
        };
        ClearAllErrors = async () => {
            console.log('Mock ClearAllErrors called');
        };
        ExportErrorsToFile = async () => {
            console.log('Mock ExportErrorsToFile called');
            return '/path/to/exported/file.txt';
        };
        ExportErrorIDsToFile = async () => {
            console.log('Mock ExportErrorIDsToFile called');
            return '/path/to/exported/ids.txt';
        };
        return false;
    }
}

// DOM Elements
let inputSource;
let btnBrowse;
let btnProcess;
let btnCancel;
let btnSettings;
let pdfLeftIframe;
let pdfRightIframe;
let pdfLeftPlaceholder;
let pdfRightPlaceholder;
let statusDot;
let statusMessage;
let statusPhase;
let progressContainer;
let progressFill;
let progressText;

// Download dropdown elements
let downloadDropdown;
let btnDownload;
let downloadMenu;

// Settings modal elements
let settingsModal;
let settingApiKey;
let settingBaseUrl;
let settingModel;
let settingContextWindow;
let settingCompiler;
let settingWorkdir;
let settingConcurrency;
let settingLibraryPageSize;
let btnBrowseWorkdir;
let btnSettingsCancel;
let btnSettingsSave;
let btnTestConnection;
let testStatus;
let modalClose;

// About modal elements
let aboutModal;
let btnAbout;
let aboutModalClose;
let btnAboutClose;

// Results management modal elements
let resultsModal;
let btnResults;
let resultsModalClose;
let btnResultsClose;
let resultsList;
let resultsEmpty;

// Share modal elements
let shareModal;
let btnShare;
let shareModalClose;
let btnShareCancel;
let btnShareConfirm;
let shareChineseCheck;
let shareBilingualCheck;
let shareChineseName;
let shareBilingualName;
let shareChineseStatus;
let shareBilingualStatus;
let shareWarning;
let shareProgress;

// GitHub settings elements
let settingGitHubToken;
let btnUpdateGitHubToken;
let btnTestGitHub;
let githubTestStatus;
let githubUpdateStatus;

// Default GitHub repository settings
const DEFAULT_GITHUB_OWNER = 'rapidaicoder';
const DEFAULT_GITHUB_REPO = 'chinesepaper';

// arXiv Search elements
let arxivSearchInput;
let btnArxivSearch;
let btnBrowseLibrary;

// Browse Library Modal elements
let browseLibraryModal;
let libraryModalClose;
let btnLibraryClose;
let libraryLoading;
let libraryContent;
let libraryList;
let libraryEmpty;
let libraryPagination;
let btnFirstPage;
let btnPrevPage;
let btnNextPage;
let btnLastPage;
let currentPageSpan;
let totalPagesSpan;
let totalPapersSpan;

// GitHub Download Modal elements
let githubDownloadModal;
let downloadModalClose;
let downloadArxivId;
let downloadChineseItem;
let downloadChineseCheck;
let downloadChineseName;
let downloadBilingualItem;
let downloadBilingualCheck;
let downloadBilingualName;
let downloadLatexItem;
let downloadLatexCheck;
let downloadLatexName;
let downloadProgress;
let downloadProgressText;
let btnDownloadCancel;
let btnDownloadConfirm;

// Translate Confirm Modal elements
let translateConfirmModal;
let translateConfirmModalClose;
let translateConfirmIntro;
let previewArxivId;
let previewTitle;
let previewAuthors;
let btnTranslateCancel;
let btnTranslateConfirm;
let pendingTranslateArxivId = null;

// Current download state
let currentDownloadData = null;

// Library browser state
let allPapers = []; // All papers from GitHub
let currentPage = 1;
let pageSize = 20; // Default page size, will be loaded from config
let totalPages = 1;

// Startup check modal elements
let startupCheckModal;
let latexSpinner;
let latexStatus;
let latexDetail;
let latexAction;
let latexDownloadLink;
let llmSpinner;
let llmStatus;
let llmDetail;
let llmAction;
let btnConfigureLlm;
let btnRecheck;
let btnContinue;
let checkLatexItem;
let checkLlmItem;

// PDF Translation mode elements
let modeTabLatex;
let modeTabPdf;
let latexInputSection;
let pdfInputSection;
let pdfDropZone;
let btnSelectPdf;
let pdfFileSelected;
let pdfFileName;
let pdfFileSize;
let btnClearPdf;
let btnTranslatePdf;
let btnDownloadTranslated;

// PDF sync scrolling state
let isSyncScrolling = false;
let translatedPdfPath = null;

// Track if API test passed
let apiTestPassed = false;

// Track original LLM settings to detect changes
let originalLlmSettings = {
    apiKey: '',
    baseUrl: '',
    model: ''
};

// Application state
let isProcessing = false;
let statusPollInterval = null;
let currentResult = null; // Store the current processing result

// PDF Translation state
let currentMode = 'latex'; // 'latex' or 'pdf'
let isPdfTranslating = false;
let pdfStatusPollInterval = null;
let currentPdfInfo = null; // Store loaded PDF info
let currentPdfFilePath = null; // Store selected PDF file path
let currentPdfTranslatedPath = null; // Store translated PDF path for PDF mode

// æ¨¡å¼åˆ‡æ¢æ—¶ä¿å­˜çš„ PDF è·¯å¾„
let latexModeLeftPdf = null;  // LaTeX æ¨¡å¼å·¦ä¾§ PDF è·¯å¾„
let latexModeRightPdf = null; // LaTeX æ¨¡å¼å³ä¾§ PDF è·¯å¾„
let pdfModeLeftPdf = null;    // PDF æ¨¡å¼å·¦ä¾§ PDF è·¯å¾„
let pdfModeRightPdf = null;   // PDF æ¨¡å¼å³ä¾§ PDF è·¯å¾„

// æ¨¡å¼åˆ‡æ¢æ—¶ä¿å­˜çš„çŠ¶æ€æ çŠ¶æ€
let latexModeStatus = { phase: 'idle', progress: 0, message: 'å°±ç»ª', error: null };
let pdfModeStatus = { phase: 'idle', progress: 0, message: 'å°±ç»ª', error: null };

// Toast container element
let toastContainer;

/**
 * Show a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'success', 'error', 'warning', 'info'
 * @param {number} duration - Duration in ms (default 3000)
 */
function showToast(message, type = 'info', duration = 3000) {
    if (!toastContainer) {
        toastContainer = document.getElementById('toast-container');
    }

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Auto remove after duration
    setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => {
            toast.remove();
        }, 300);
    }, duration);
}

/**
 * Phase display names mapping
 */
const phaseDisplayNames = {
    'idle': 'ç©ºé—²',
    'downloading': 'ä¸‹è½½ä¸­',
    'extracting': 'è§£å‹ä¸­',
    'compiling': 'ç¼–è¯‘ä¸­',
    'translating': 'ç¿»è¯‘ä¸­',
    'validating': 'éªŒè¯ä¸­',
    'complete': 'å®Œæˆ',
    'error': 'é”™è¯¯',
    // PDF Translation phases
    'loading': 'åŠ è½½ä¸­',
    'generating': 'ç”Ÿæˆä¸­'
};

/**
 * Initialize DOM element references
 */
function initElements() {
    inputSource = document.getElementById('input-source');
    btnBrowse = document.getElementById('btn-browse');
    btnProcess = document.getElementById('btn-process');
    btnCancel = document.getElementById('btn-cancel');
    btnSettings = document.getElementById('btn-settings');
    pdfLeftIframe = document.getElementById('pdf-left-iframe');
    pdfRightIframe = document.getElementById('pdf-right-iframe');
    pdfLeftPlaceholder = document.getElementById('pdf-left-placeholder');
    pdfRightPlaceholder = document.getElementById('pdf-right-placeholder');
    statusDot = document.getElementById('status-dot');
    statusMessage = document.getElementById('status-message');
    statusPhase = document.getElementById('status-phase');
    progressContainer = document.getElementById('progress-container');
    progressFill = document.getElementById('progress-fill');
    progressText = document.getElementById('progress-text');

    // Download dropdown elements
    downloadDropdown = document.getElementById('download-dropdown');
    btnDownload = document.getElementById('btn-download');
    downloadMenu = document.getElementById('download-menu');

    // Settings modal elements
    settingsModal = document.getElementById('settings-modal');
    settingApiKey = document.getElementById('setting-api-key');
    settingBaseUrl = document.getElementById('setting-base-url');
    settingModel = document.getElementById('setting-model');
    settingContextWindow = document.getElementById('setting-context-window');
    settingCompiler = document.getElementById('setting-compiler');
    settingWorkdir = document.getElementById('setting-workdir');
    settingConcurrency = document.getElementById('setting-concurrency');
    settingLibraryPageSize = document.getElementById('setting-library-page-size');
    btnBrowseWorkdir = document.getElementById('btn-browse-workdir');
    btnSettingsCancel = document.getElementById('btn-settings-cancel');
    btnSettingsSave = document.getElementById('btn-settings-save');
    btnTestConnection = document.getElementById('btn-test-connection');
    testStatus = document.getElementById('test-status');
    modalClose = document.getElementById('modal-close');

    // About modal elements
    aboutModal = document.getElementById('about-modal');
    btnAbout = document.getElementById('btn-about');
    aboutModalClose = document.getElementById('about-modal-close');
    btnAboutClose = document.getElementById('btn-about-close');

    // Results management modal elements
    resultsModal = document.getElementById('results-modal');
    btnResults = document.getElementById('btn-results');
    resultsModalClose = document.getElementById('results-modal-close');
    btnResultsClose = document.getElementById('btn-results-close');
    resultsList = document.getElementById('results-list');
    resultsEmpty = document.getElementById('results-empty');

    // Share modal elements
    shareModal = document.getElementById('share-modal');
    btnShare = document.getElementById('btn-share');
    shareModalClose = document.getElementById('share-modal-close');
    btnShareCancel = document.getElementById('btn-share-cancel');
    btnShareConfirm = document.getElementById('btn-share-confirm');
    shareChineseCheck = document.getElementById('share-chinese-check');
    shareBilingualCheck = document.getElementById('share-bilingual-check');
    shareChineseName = document.getElementById('share-chinese-name');
    shareBilingualName = document.getElementById('share-bilingual-name');
    shareChineseStatus = document.getElementById('share-chinese-status');
    shareBilingualStatus = document.getElementById('share-bilingual-status');
    shareWarning = document.getElementById('share-warning');
    shareProgress = document.getElementById('share-progress');

    // GitHub settings elements
    settingGitHubToken = document.getElementById('setting-github-token');
    btnUpdateGitHubToken = document.getElementById('btn-update-github-token');
    btnTestGitHub = document.getElementById('btn-test-github');
    githubTestStatus = document.getElementById('github-test-status');
    githubUpdateStatus = document.getElementById('github-update-status');

    // Startup check modal elements
    startupCheckModal = document.getElementById('startup-check-modal');
    latexSpinner = document.getElementById('latex-spinner');
    latexStatus = document.getElementById('latex-status');
    latexDetail = document.getElementById('latex-detail');
    latexAction = document.getElementById('latex-action');
    latexDownloadLink = document.getElementById('latex-download-link');
    llmSpinner = document.getElementById('llm-spinner');
    llmStatus = document.getElementById('llm-status');
    llmDetail = document.getElementById('llm-detail');
    llmAction = document.getElementById('llm-action');
    btnConfigureLlm = document.getElementById('btn-configure-llm');
    btnRecheck = document.getElementById('btn-recheck');
    btnContinue = document.getElementById('btn-continue');
    checkLatexItem = document.getElementById('check-latex');
    checkLlmItem = document.getElementById('check-llm');

    // PDF Translation mode elements
    modeTabLatex = document.getElementById('mode-tab-latex');
    modeTabPdf = document.getElementById('mode-tab-pdf');
    latexInputSection = document.getElementById('latex-input-section');
    pdfInputSection = document.getElementById('pdf-input-section');
    pdfDropZone = document.getElementById('pdf-drop-zone');
    btnSelectPdf = document.getElementById('btn-select-pdf');
    pdfFileSelected = document.getElementById('pdf-file-selected');
    pdfFileName = document.getElementById('pdf-file-name');
    pdfFileSize = document.getElementById('pdf-file-size');
    btnClearPdf = document.getElementById('btn-clear-pdf');
    btnTranslatePdf = document.getElementById('btn-translate-pdf');
    btnDownloadTranslated = document.getElementById('btn-download-translated');

    // arXiv Search elements
    arxivSearchInput = document.getElementById('arxiv-search-input');
    btnArxivSearch = document.getElementById('btn-arxiv-search');
    btnBrowseLibrary = document.getElementById('btn-browse-library');

    // Browse Library Modal elements
    browseLibraryModal = document.getElementById('browse-library-modal');
    libraryModalClose = document.getElementById('library-modal-close');
    btnLibraryClose = document.getElementById('btn-library-close');
    libraryLoading = document.getElementById('library-loading');
    libraryContent = document.getElementById('library-content');
    libraryList = document.getElementById('library-list');
    libraryEmpty = document.getElementById('library-empty');
    libraryPagination = document.getElementById('library-pagination');
    btnFirstPage = document.getElementById('btn-first-page');
    btnPrevPage = document.getElementById('btn-prev-page');
    btnNextPage = document.getElementById('btn-next-page');
    btnLastPage = document.getElementById('btn-last-page');
    currentPageSpan = document.getElementById('current-page');
    totalPagesSpan = document.getElementById('total-pages');
    totalPapersSpan = document.getElementById('total-papers');

    // GitHub Download Modal elements
    githubDownloadModal = document.getElementById('github-download-modal');
    downloadModalClose = document.getElementById('download-modal-close');
    downloadArxivId = document.getElementById('download-arxiv-id');
    downloadChineseItem = document.getElementById('download-chinese-item');
    downloadChineseCheck = document.getElementById('download-chinese-check');
    downloadChineseName = document.getElementById('download-chinese-name');
    downloadBilingualItem = document.getElementById('download-bilingual-item');
    downloadBilingualCheck = document.getElementById('download-bilingual-check');
    downloadBilingualName = document.getElementById('download-bilingual-name');
    downloadLatexItem = document.getElementById('download-latex-item');
    downloadLatexCheck = document.getElementById('download-latex-check');
    downloadLatexName = document.getElementById('download-latex-name');
    downloadProgress = document.getElementById('download-progress');
    downloadProgressText = document.getElementById('download-progress-text');
    btnDownloadCancel = document.getElementById('btn-download-cancel');
    btnDownloadConfirm = document.getElementById('btn-download-confirm');

    // Translate Confirm Modal elements
    translateConfirmModal = document.getElementById('translate-confirm-modal');
    translateConfirmModalClose = document.getElementById('translate-confirm-modal-close');
    translateConfirmIntro = document.getElementById('translate-confirm-intro');
    previewArxivId = document.getElementById('preview-arxiv-id');
    previewTitle = document.getElementById('preview-title');
    previewAuthors = document.getElementById('preview-authors');
    btnTranslateCancel = document.getElementById('btn-translate-cancel');
    btnTranslateConfirm = document.getElementById('btn-translate-confirm');
}

/**
 * Set up event listeners for UI interactions
 */
function setupEventListeners() {
    // Process button click
    btnProcess.addEventListener('click', handleProcess);

    // Cancel button click
    btnCancel.addEventListener('click', handleCancel);

    // Browse button click
    btnBrowse.addEventListener('click', handleBrowse);

    // Settings button click
    btnSettings.addEventListener('click', openSettings);

    // Download dropdown events
    btnDownload.addEventListener('click', toggleDownloadMenu);
    document.getElementById('download-chinese-pdf').addEventListener('click', () => downloadFile('chinese'));
    document.getElementById('download-bilingual-pdf').addEventListener('click', () => downloadFile('bilingual'));
    document.getElementById('download-latex-zip').addEventListener('click', () => downloadFile('latex'));

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!downloadDropdown.contains(e.target)) {
            downloadMenu.classList.remove('show');
        }
    });

    // Settings modal events
    modalClose.addEventListener('click', closeSettings);
    btnSettingsCancel.addEventListener('click', closeSettings);
    btnSettingsSave.addEventListener('click', saveSettings);
    btnTestConnection.addEventListener('click', testConnection);
    btnBrowseWorkdir.addEventListener('click', browseWorkdir);

    // Reset test status when settings change
    settingApiKey.addEventListener('input', resetTestStatus);
    settingBaseUrl.addEventListener('input', resetTestStatus);
    settingModel.addEventListener('input', resetTestStatus);

    // Close modal when clicking overlay (but not modal content)
    settingsModal.addEventListener('mousedown', (e) => {
        // Only close if clicking directly on the overlay, not on any child elements
        if (e.target === settingsModal) {
            closeSettings();
        }
    });

    // Prevent keyboard shortcuts from being intercepted by Wails when in modal
    settingsModal.addEventListener('keydown', (e) => {
        // Allow all keyboard events inside the modal
        e.stopPropagation();
    });

    // About modal events
    btnAbout.addEventListener('click', openAbout);
    aboutModalClose.addEventListener('click', closeAbout);
    btnAboutClose.addEventListener('click', closeAbout);
    aboutModal.addEventListener('mousedown', (e) => {
        if (e.target === aboutModal) {
            closeAbout();
        }
    });

    // GitHub link - open in external browser
    document.getElementById('github-link').addEventListener('click', (e) => {
        e.preventDefault();
        OpenURLInBrowser('https://github.com/RapidAI/RapidTrans');
    });

    // Results management modal events
    btnResults.addEventListener('click', openResults);
    resultsModalClose.addEventListener('click', closeResults);
    btnResultsClose.addEventListener('click', closeResults);
    resultsModal.addEventListener('mousedown', (e) => {
        if (e.target === resultsModal) {
            closeResults();
        }
    });

    // Share modal events
    btnShare.addEventListener('click', openShare);
    shareModalClose.addEventListener('click', closeShare);
    btnShareCancel.addEventListener('click', closeShare);
    btnShareConfirm.addEventListener('click', confirmShare);
    shareModal.addEventListener('mousedown', (e) => {
        if (e.target === shareModal) {
            closeShare();
        }
    });

    // GitHub settings events
    btnUpdateGitHubToken.addEventListener('click', updateGitHubToken);
    btnTestGitHub.addEventListener('click', testGitHubConnection);

    // Startup check modal events
    btnRecheck.addEventListener('click', performStartupCheck);
    btnContinue.addEventListener('click', closeStartupCheckModal);
    btnConfigureLlm.addEventListener('click', () => {
        closeStartupCheckModal();
        openSettings();
    });
    latexDownloadLink.addEventListener('click', async (e) => {
        e.preventDefault();
        const url = await GetLaTeXDownloadURL();
        OpenURLInBrowser(url);
    });

    // Enter key in input field
    inputSource.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isProcessing) {
            handleProcess();
        }
    });

    // Listen for status updates from backend (if using events)
    EventsOn('status-update', handleStatusUpdate);

    // Listen for PDF ready events
    EventsOn('original-pdf-ready', (pdfPath) => {
        console.log('Original PDF ready:', pdfPath);
        loadPDF('left', pdfPath);
    });

    EventsOn('translated-pdf-ready', (pdfPath) => {
        console.log('Translated PDF ready:', pdfPath);
        loadPDF('right', pdfPath);
    });

    // PDF Translation mode event listeners
    setupPdfModeEventListeners();

    // arXiv Search event listeners
    btnArxivSearch.addEventListener('click', handleArxivSearch);
    arxivSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleArxivSearch();
        }
    });

    // Browse Library event listeners
    btnBrowseLibrary.addEventListener('click', openBrowseLibrary);
    libraryModalClose.addEventListener('click', closeBrowseLibrary);
    btnLibraryClose.addEventListener('click', closeBrowseLibrary);
    browseLibraryModal.addEventListener('mousedown', (e) => {
        if (e.target === browseLibraryModal) {
            closeBrowseLibrary();
        }
    });
    
    // Pagination event listeners
    btnFirstPage.addEventListener('click', () => goToPage(1));
    btnPrevPage.addEventListener('click', () => goToPage(currentPage - 1));
    btnNextPage.addEventListener('click', () => goToPage(currentPage + 1));
    btnLastPage.addEventListener('click', () => goToPage(totalPages));

    // GitHub Download Modal event listeners
    downloadModalClose.addEventListener('click', closeDownloadModal);
    btnDownloadCancel.addEventListener('click', closeDownloadModal);
    btnDownloadConfirm.addEventListener('click', confirmDownload);
    githubDownloadModal.addEventListener('mousedown', (e) => {
        if (e.target === githubDownloadModal) {
            closeDownloadModal();
        }
    });

    // Translate Confirm Modal event listeners
    translateConfirmModalClose.addEventListener('click', closeTranslateConfirmModal);
    btnTranslateCancel.addEventListener('click', closeTranslateConfirmModal);
    btnTranslateConfirm.addEventListener('click', confirmTranslate);
    translateConfirmModal.addEventListener('mousedown', (e) => {
        if (e.target === translateConfirmModal) {
            closeTranslateConfirmModal();
        }
    });
}

/**
 * Toggle download dropdown menu
 */
function toggleDownloadMenu(e) {
    e.stopPropagation();
    downloadMenu.classList.toggle('show');
}

/**
 * Download file based on type
 * @param {string} type - 'chinese', 'bilingual', or 'latex'
 */
async function downloadFile(type) {
    downloadMenu.classList.remove('show');

    if (!currentResult) {
        showToast('æ²¡æœ‰å¯ä¸‹è½½çš„å†…å®¹ï¼Œè¯·å…ˆå¤„ç†æ–‡æ¡£', 'warning');
        return;
    }

    try {
        let savePath;
        switch (type) {
            case 'chinese':
                showToast('æ­£åœ¨å‡†å¤‡ä¸­æ–‡ PDF...', 'info');
                savePath = await DownloadChinesePDF();
                if (savePath) {
                    showToast('ä¸­æ–‡ PDF å·²ä¿å­˜', 'success');
                }
                break;
            case 'bilingual':
                showToast('æ­£åœ¨ç”Ÿæˆä¸­è‹±å¯¹ç…§ PDF...', 'info');
                savePath = await DownloadBilingualPDF();
                if (savePath) {
                    showToast('ä¸­è‹±å¯¹ç…§ PDF å·²ä¿å­˜', 'success');
                }
                break;
            case 'latex':
                showToast('æ­£åœ¨æ‰“åŒ… LaTeX æ–‡ä»¶...', 'info');
                savePath = await DownloadLatexZip();
                if (savePath) {
                    showToast('LaTeX æ–‡ä»¶å·²ä¿å­˜', 'success');
                }
                break;
        }
    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Handle the browse button click to select a local zip file
 */
async function handleBrowse() {
    try {
        const result = await OpenFileDialog();
        if (result) {
            inputSource.value = result;
        }
    } catch (error) {
        console.error('Error opening file dialog:', error);
        showError('æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†å¤±è´¥');
    }
}

/**
 * Handle the process button click to start processing
 */
async function handleProcess() {
    const input = inputSource.value.trim();

    if (!input) {
        showError('è¯·è¾“å…¥ arXiv URLã€arXiv ID æˆ–æœ¬åœ° zip æ–‡ä»¶è·¯å¾„');
        return;
    }

    // Save the input for next time
    SaveLastInput(input);

    try {
        // Check for existing translation first
        const existingInfo = await CheckExistingTranslation(input);

        if (existingInfo && existingInfo.exists) {
            // Show confirmation dialog
            let confirmMsg = existingInfo.message + '\n\n';
            if (existingInfo.is_complete) {
                confirmMsg += 'æ˜¯å¦è¦é‡æ–°ç¿»è¯‘ï¼Ÿï¼ˆè¿™å°†è¦†ç›–ç°æœ‰ç»“æœï¼‰\n\nç‚¹å‡»"ç¡®å®š"é‡æ–°ç¿»è¯‘ï¼Œç‚¹å‡»"å–æ¶ˆ"æŸ¥çœ‹ç°æœ‰ç»“æœ';
            } else if (existingInfo.can_continue) {
                confirmMsg += 'æ˜¯å¦è¦ç»§ç»­ç¿»è¯‘ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"ç»§ç»­ï¼Œç‚¹å‡»"å–æ¶ˆ"é‡æ–°å¼€å§‹';
            }

            const userChoice = confirm(confirmMsg);

            if (existingInfo.is_complete && !userChoice) {
                // User wants to view existing result
                if (existingInfo.paper_info && existingInfo.paper_info.arxiv_id) {
                    showToast('æ­£åœ¨åŠ è½½å·²æœ‰ç¿»è¯‘ç»“æœ...', 'info');
                    const result = await OpenPaperResult(existingInfo.paper_info.arxiv_id);
                    if (result) {
                        currentResult = result;
                        downloadDropdown.style.display = 'inline-block';
                        btnShare.style.display = 'inline-block';
                        if (result.original_pdf_path) {
                            loadPDF('left', result.original_pdf_path);
                        }
                        if (result.translated_pdf_path) {
                            loadPDF('right', result.translated_pdf_path);
                        }
                        showToast('å·²åŠ è½½ç°æœ‰ç¿»è¯‘ç»“æœ', 'success');
                    }
                }
                return;
            }

            // User wants to re-translate or continue
            // Update UI to processing state
            setProcessingState(true);
            resetPDFViewers();
            updateStatus('idle', 0, userChoice ? 'å¼€å§‹å¤„ç†...' : 'ç»§ç»­ç¿»è¯‘...');
            startStatusPolling();

            // Call backend with force option
            const result = await ProcessSourceWithForce(input, userChoice);

            stopStatusPolling();
            handleProcessResult(result);
            return;
        }
    } catch (checkError) {
        console.warn('Failed to check existing translation:', checkError);
        // Continue with normal processing if check fails
    }

    // No existing translation, proceed normally
    setProcessingState(true);
    resetPDFViewers();
    updateStatus('idle', 0, 'å¼€å§‹å¤„ç†...');

    try {
        // Start status polling
        startStatusPolling();

        // Call backend ProcessSource
        const result = await ProcessSource(input);

        // Stop status polling
        stopStatusPolling();

        handleProcessResult(result);
    } catch (error) {
        console.error('Processing error:', error);
        stopStatusPolling();

        // Extract error message
        const errorMsg = error.message || error.toString() || 'å¤„ç†å¤±è´¥';
        updateStatus('error', 0, errorMsg);
        showError(errorMsg);
    } finally {
        setProcessingState(false);
    }
}

/**
 * Handle the process result
 */
function handleProcessResult(result) {
    if (result) {
        // Store the result for download
        currentResult = result;

        // Processing completed successfully
        updateStatus('complete', 100, 'å¤„ç†å®Œæˆ');

        // Show download button
        downloadDropdown.style.display = 'inline-block';

        // Show share button
        btnShare.style.display = 'inline-block';

        // Load PDFs into iframes
        if (result.original_pdf_path) {
            loadPDF('left', result.original_pdf_path);
        }
        if (result.translated_pdf_path) {
            loadPDF('right', result.translated_pdf_path);
        }

        showToast('å¤„ç†å®Œæˆï¼Œå¯ä»¥ä¸‹è½½ç»“æœ', 'success');
    }
    setProcessingState(false);
}

/**
 * Handle the cancel button click to cancel processing
 */
async function handleCancel() {
    try {
        await CancelProcess();
        stopStatusPolling();
        updateStatus('idle', 0, 'å¤„ç†å·²å–æ¶ˆ');
        setProcessingState(false);
    } catch (error) {
        console.error('Cancel error:', error);
        showError('å–æ¶ˆå¤„ç†å¤±è´¥');
    }
}

/**
 * Handle status update from backend event
 * @param {Object} status - Status object from backend
 */
function handleStatusUpdate(status) {
    if (status) {
        updateStatus(status.phase, status.progress, status.message, status.error);
    }
}

/**
 * Start polling for status updates
 */
function startStatusPolling() {
    // Poll every 500ms
    statusPollInterval = setInterval(async () => {
        try {
            const status = await GetStatus();
            if (status) {
                updateStatus(status.phase, status.progress, status.message, status.error);
            }
        } catch (error) {
            console.error('Status poll error:', error);
        }
    }, 500);
}

/**
 * Stop polling for status updates
 */
function stopStatusPolling() {
    if (statusPollInterval) {
        clearInterval(statusPollInterval);
        statusPollInterval = null;
    }
}

/**
 * Update the UI to reflect processing state
 * @param {boolean} processing - Whether processing is in progress
 */
function setProcessingState(processing) {
    isProcessing = processing;

    // Update button visibility
    btnProcess.disabled = processing;
    btnProcess.style.display = processing ? 'none' : 'inline-block';
    btnCancel.style.display = processing ? 'inline-block' : 'none';

    // Update input state
    inputSource.disabled = processing;
    btnBrowse.disabled = processing;

    // Update progress container visibility
    if (processing) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }
}

/**
 * Update the status display
 * @param {string} phase - Current processing phase
 * @param {number} progress - Progress percentage (0-100)
 * @param {string} message - Status message
 * @param {string} [error] - Error message if any
 */
function updateStatus(phase, progress, message, error) {
    // ä¿å­˜çŠ¶æ€åˆ°å½“å‰æ¨¡å¼çš„çŠ¶æ€å˜é‡
    const statusState = { phase, progress, message: message || 'å°±ç»ª', error: error || null };
    if (currentMode === 'latex') {
        latexModeStatus = statusState;
    } else {
        pdfModeStatus = statusState;
    }

    // Update status dot
    statusDot.className = 'status-dot';
    if (phase === 'error') {
        statusDot.classList.add('error');
    } else if (phase === 'complete') {
        statusDot.classList.add('success');
    } else if (phase !== 'idle') {
        statusDot.classList.add('processing');
    } else {
        statusDot.classList.add('idle');
    }

    // Update status message
    if (error) {
        statusMessage.textContent = error;
        statusMessage.style.color = '#f44336';
    } else {
        statusMessage.textContent = message || 'å°±ç»ª';
        statusMessage.style.color = '';
    }

    // Update phase display
    statusPhase.textContent = phaseDisplayNames[phase] || phase;

    // Update progress bar
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${progress}%`;
}

/**
 * ç›´æ¥åº”ç”¨çŠ¶æ€æ˜¾ç¤ºï¼ˆä¸ä¿å­˜åˆ°çŠ¶æ€å˜é‡ï¼‰
 * ç”¨äºæ¨¡å¼åˆ‡æ¢æ—¶æ¢å¤çŠ¶æ€
 * @param {Object} status - çŠ¶æ€å¯¹è±¡ { phase, progress, message, error }
 */
function applyStatusDisplay(status) {
    const { phase, progress, message, error } = status;

    // Update status dot
    statusDot.className = 'status-dot';
    if (phase === 'error') {
        statusDot.classList.add('error');
    } else if (phase === 'complete') {
        statusDot.classList.add('success');
    } else if (phase !== 'idle') {
        statusDot.classList.add('processing');
    } else {
        statusDot.classList.add('idle');
    }

    // Update status message
    if (error) {
        statusMessage.textContent = error;
        statusMessage.style.color = '#f44336';
    } else {
        statusMessage.textContent = message || 'å°±ç»ª';
        statusMessage.style.color = '';
    }

    // Update phase display
    statusPhase.textContent = phaseDisplayNames[phase] || phase;

    // Update progress bar
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${progress}%`;
}

/**
 * Reset PDF viewers to placeholder state
 */
function resetPDFViewers() {
    // Hide iframes, show placeholders
    pdfLeftIframe.style.display = 'none';
    pdfRightIframe.style.display = 'none';
    pdfLeftPlaceholder.style.display = 'flex';
    pdfRightPlaceholder.style.display = 'flex';

    // Clear iframe sources - use about:blank to prevent loading main page
    pdfLeftIframe.src = 'about:blank';
    pdfRightIframe.src = 'about:blank';
}

/**
 * Load a PDF into the specified viewer
 * @param {string} side - 'left' or 'right'
 * @param {string} pdfPath - Path to the PDF file
 */
async function loadPDF(side, pdfPath) {
    const iframe = side === 'left' ? pdfLeftIframe : pdfRightIframe;
    const placeholder = side === 'left' ? pdfLeftPlaceholder : pdfRightPlaceholder;

    if (!pdfPath) {
        return;
    }

    console.log('Loading PDF:', side, pdfPath);

    // Convert local file path to our custom /pdf/ URL
    // The backend PDFHandler will serve the file
    let pdfUrl = '/pdf/' + pdfPath.replace(/\\/g, '/');

    console.log('PDF URL:', pdfUrl);

    // Hide placeholder, show iframe
    placeholder.style.display = 'none';
    iframe.style.display = 'block';
    iframe.src = pdfUrl;
}

/**
 * Show an error message to the user
 * @param {string} message - Error message to display
 */
function showError(message) {
    // Update status to show error
    updateStatus('error', 0, message);

    // Show toast notification
    showToast(message, 'error', 5000);
    console.error('Error:', message);
}

/**
 * Open the settings modal and load current settings
 */
async function openSettings() {
    try {
        // Load current settings from backend
        const settings = await GetSettings();

        // Populate form fields
        settingApiKey.value = settings.openai_api_key || '';
        settingBaseUrl.value = settings.openai_base_url || 'https://api.openai.com/v1';
        settingModel.value = settings.openai_model || 'gpt-4';
        settingContextWindow.value = settings.context_window || 8192;
        settingCompiler.value = settings.default_compiler || 'pdflatex';
        settingWorkdir.value = settings.work_directory || '';
        settingConcurrency.value = settings.concurrency || 3;
        settingLibraryPageSize.value = settings.library_page_size || 20;

        // GitHub settings (only token, owner and repo use defaults)
        settingGitHubToken.value = settings.github_token || '';

        // Store original LLM settings to detect changes
        originalLlmSettings = {
            apiKey: settings.openai_api_key || '',
            baseUrl: settings.openai_base_url || 'https://api.openai.com/v1',
            model: settings.openai_model || 'gpt-4'
        };

        // If LLM is already configured (has API key), consider it as tested
        // User only needs to re-test if they change LLM settings
        apiTestPassed = (settings.openai_api_key && settings.openai_api_key.length > 0);

        // Reset test status display
        if (apiTestPassed) {
            testStatus.textContent = 'âœ… å·²é…ç½®';
            testStatus.className = 'test-status success';
        } else {
            testStatus.textContent = '';
            testStatus.className = 'test-status';
        }
        githubTestStatus.textContent = '';
        githubTestStatus.className = 'test-status';

        // Show modal
        settingsModal.classList.add('visible');
    } catch (error) {
        console.error('Error loading settings:', error);
        showError('åŠ è½½è®¾ç½®å¤±è´¥');
    }
}

/**
 * Close the settings modal
 */
function closeSettings() {
    settingsModal.classList.remove('visible');
    apiTestPassed = false;
}

/**
 * Open the about modal
 */
function openAbout() {
    aboutModal.classList.add('visible');
}

/**
 * Close the about modal
 */
function closeAbout() {
    aboutModal.classList.remove('visible');
}

/**
 * Open the results management modal
 */
async function openResults() {
    resultsModal.classList.add('visible');
    await loadPapersList();
}

/**
 * Close the results management modal
 */
function closeResults() {
    resultsModal.classList.remove('visible');
}

/**
 * Load and display the list of translated papers
 */
async function loadPapersList() {
    try {
        const papers = await ListTranslatedPapers();

        // Clear existing items (except the empty placeholder)
        const existingItems = resultsList.querySelectorAll('.paper-item');
        existingItems.forEach(item => item.remove());

        if (!papers || papers.length === 0) {
            resultsEmpty.style.display = 'block';
            return;
        }

        resultsEmpty.style.display = 'none';

        // Add paper items
        papers.forEach(paper => {
            const item = createPaperItem(paper);
            resultsList.appendChild(item);
        });
    } catch (error) {
        console.error('Failed to load papers list:', error);
        showToast('åŠ è½½è®ºæ–‡åˆ—è¡¨å¤±è´¥', 'error');
    }
}

/**
 * Create a paper item element
 */
function createPaperItem(paper) {
    const item = document.createElement('div');
    item.className = 'paper-item';
    item.dataset.arxivId = paper.arxiv_id;

    // Determine status display
    const status = paper.status || 'complete';
    const isComplete = status === 'complete';
    const isError = status === 'error';
    const statusText = getStatusText(status);
    const statusClass = isComplete ? 'status-complete' : (isError ? 'status-error' : 'status-pending');

    // Show continue button for incomplete/error translations
    const showContinue = !isComplete;
    const showView = isComplete || paper.original_pdf;
    const showShare = isComplete; // Only show share for completed translations

    item.innerHTML = `
        <span class="paper-icon">${isComplete ? 'ğŸ“„' : (isError ? 'âŒ' : 'â³')}</span>
        <div class="paper-info">
            <div class="paper-title" title="${escapeHtml(paper.title)}">${escapeHtml(paper.title)}</div>
            <div class="paper-meta">
                <span class="paper-arxiv-id">${escapeHtml(paper.arxiv_id)}</span>
                <span class="paper-status ${statusClass}">${statusText}</span>
                <span class="paper-date">${paper.translated_at}</span>
            </div>
            ${paper.error_message ? `<div class="paper-error" title="${escapeHtml(paper.error_message)}">é”™è¯¯: ${escapeHtml(paper.error_message.substring(0, 50))}${paper.error_message.length > 50 ? '...' : ''}</div>` : ''}
        </div>
        <div class="paper-actions">
            ${showView ? '<button class="paper-btn paper-btn-view" title="æŸ¥çœ‹">ğŸ‘ï¸ æŸ¥çœ‹</button>' : ''}
            ${showShare ? '<button class="paper-btn paper-btn-share" title="åˆ†äº«åˆ° GitHub">ğŸ“¤ åˆ†äº«</button>' : ''}
            ${showContinue ? '<button class="paper-btn paper-btn-continue" title="ç»§ç»­ç¿»è¯‘">â–¶ï¸ ç»§ç»­</button>' : ''}
            <button class="paper-btn paper-btn-retranslate" title="é‡æ–°ç¿»è¯‘">ğŸ”„ é‡è¯‘</button>
            <button class="paper-btn paper-btn-delete" title="åˆ é™¤">ğŸ—‘ï¸</button>
        </div>
    `;

    // Add event listeners
    if (showView) {
        item.querySelector('.paper-btn-view').addEventListener('click', () => viewPaper(paper.arxiv_id));
    }
    if (showShare) {
        item.querySelector('.paper-btn-share').addEventListener('click', () => sharePaper(paper.arxiv_id));
    }
    if (showContinue) {
        item.querySelector('.paper-btn-continue').addEventListener('click', () => continuePaper(paper.arxiv_id));
    }
    item.querySelector('.paper-btn-retranslate').addEventListener('click', () => retranslatePaper(paper.arxiv_id));
    item.querySelector('.paper-btn-delete').addEventListener('click', () => deletePaper(paper.arxiv_id, item));

    return item;
}

/**
 * Get human-readable status text
 */
function getStatusText(status) {
    const statusMap = {
        'pending': 'å¾…å¤„ç†',
        'downloading': 'ä¸‹è½½ä¸­',
        'extracted': 'å·²è§£å‹',
        'original_compiled': 'åŸæ–‡å·²ç¼–è¯‘',
        'translating': 'ç¿»è¯‘ä¸­',
        'translated': 'å·²ç¿»è¯‘',
        'compiling': 'ç¼–è¯‘ä¸­',
        'complete': 'å®Œæˆ',
        'error': 'é”™è¯¯'
    };
    return statusMap[status] || status;
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * View a previously translated paper
 */
async function viewPaper(arxivId) {
    try {
        closeResults();
        showToast('æ­£åœ¨åŠ è½½è®ºæ–‡...', 'info');

        const result = await OpenPaperResult(arxivId);
        if (result) {
            currentResult = result;
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';
            showToast('è®ºæ–‡åŠ è½½å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to view paper:', error);
        showToast('åŠ è½½è®ºæ–‡å¤±è´¥: ' + (error.message || error), 'error');
    }
}

// Store arxivId for paper share modal
let currentShareArxivId = null;

/**
 * Share a paper to GitHub from results list
 */
async function sharePaper(arxivId) {
    try {
        // Check share status for this specific paper
        const status = await CheckShareStatusForPaper(arxivId);

        if (!status.can_share) {
            showToast(status.message, 'warning');
            return;
        }

        // Store arxivId for later use
        currentShareArxivId = arxivId;

        // Update file names
        shareChineseName.textContent = status.chinese_pdf_path;
        shareBilingualName.textContent = status.bilingual_pdf_path;

        // Update status badges
        if (status.chinese_pdf_exists) {
            shareChineseStatus.textContent = 'å·²å­˜åœ¨';
            shareChineseStatus.className = 'file-status exists';
        } else {
            shareChineseStatus.textContent = 'æ–°æ–‡ä»¶';
            shareChineseStatus.className = 'file-status new';
        }

        if (status.bilingual_pdf_exists) {
            shareBilingualStatus.textContent = 'å·²å­˜åœ¨';
            shareBilingualStatus.className = 'file-status exists';
        } else {
            shareBilingualStatus.textContent = 'æ–°æ–‡ä»¶';
            shareBilingualStatus.className = 'file-status new';
        }

        // Show warning if any file exists
        if (status.chinese_pdf_exists || status.bilingual_pdf_exists) {
            shareWarning.style.display = 'flex';
        } else {
            shareWarning.style.display = 'none';
        }

        // Reset checkboxes
        shareChineseCheck.checked = true;
        shareBilingualCheck.checked = true;

        // Hide progress
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;

        // Show modal
        shareModal.classList.add('visible');
    } catch (error) {
        console.error('Failed to check share status:', error);
        showToast('æ£€æŸ¥åˆ†äº«çŠ¶æ€å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Re-translate a paper from arXiv
 */
async function retranslatePaper(arxivId) {
    if (!confirm(`ç¡®å®šè¦é‡æ–°ç¿»è¯‘è®ºæ–‡ ${arxivId} å—ï¼Ÿ\nè¿™å°†ä» arXiv ä¸‹è½½æœ€æ–°ç‰ˆæœ¬å¹¶é‡æ–°ç¿»è¯‘ã€‚`)) {
        return;
    }

    try {
        closeResults();
        setProcessingState(true);
        resetPDFViewers();
        updateStatus('idle', 0, 'å¼€å§‹é‡æ–°ç¿»è¯‘...');
        startStatusPolling();

        const result = await RetranslateFromArxiv(arxivId);

        stopStatusPolling();

        if (result) {
            currentResult = result;
            updateStatus('complete', 100, 'é‡æ–°ç¿»è¯‘å®Œæˆ');
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';

            if (result.original_pdf_path) {
                loadPDF('left', result.original_pdf_path);
            }
            if (result.translated_pdf_path) {
                loadPDF('right', result.translated_pdf_path);
            }

            showToast('é‡æ–°ç¿»è¯‘å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to retranslate paper:', error);
        stopStatusPolling();
        updateStatus('error', 0, error.message || 'é‡æ–°ç¿»è¯‘å¤±è´¥');
        showToast('é‡æ–°ç¿»è¯‘å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        setProcessingState(false);
    }
}

/**
 * Continue a previously failed or incomplete translation
 */
async function continuePaper(arxivId) {
    try {
        closeResults();
        setProcessingState(true);
        resetPDFViewers();
        updateStatus('idle', 0, 'ç»§ç»­ç¿»è¯‘...');
        startStatusPolling();

        const result = await ContinueTranslation(arxivId);

        stopStatusPolling();

        if (result) {
            currentResult = result;
            updateStatus('complete', 100, 'ç¿»è¯‘å®Œæˆ');
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';

            if (result.original_pdf_path) {
                loadPDF('left', result.original_pdf_path);
            }
            if (result.translated_pdf_path) {
                loadPDF('right', result.translated_pdf_path);
            }

            showToast('ç¿»è¯‘å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to continue translation:', error);
        stopStatusPolling();
        updateStatus('error', 0, error.message || 'ç»§ç»­ç¿»è¯‘å¤±è´¥');
        showToast('ç»§ç»­ç¿»è¯‘å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        setProcessingState(false);
    }
}

/**
 * Delete a translated paper
 */
async function deletePaper(arxivId, itemElement) {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤è®ºæ–‡ ${arxivId} å—ï¼Ÿ\næ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
        return;
    }

    try {
        await DeleteTranslatedPaper(arxivId);
        itemElement.remove();

        // Check if list is now empty
        const remainingItems = resultsList.querySelectorAll('.paper-item');
        if (remainingItems.length === 0) {
            resultsEmpty.style.display = 'block';
        }

        showToast('è®ºæ–‡å·²åˆ é™¤', 'success');
    } catch (error) {
        console.error('Failed to delete paper:', error);
        showToast('åˆ é™¤å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Open the share modal
 */
async function openShare() {
    try {
        // Clear any stored arxivId (this is for sharing from main view)
        currentShareArxivId = null;

        // Check share status
        const status = await CheckShareStatus();

        if (!status.can_share) {
            showToast(status.message, 'warning');
            return;
        }

        // Update file names
        shareChineseName.textContent = status.chinese_pdf_path;
        shareBilingualName.textContent = status.bilingual_pdf_path;

        // Update status badges
        if (status.chinese_pdf_exists) {
            shareChineseStatus.textContent = 'å·²å­˜åœ¨';
            shareChineseStatus.className = 'file-status exists';
        } else {
            shareChineseStatus.textContent = 'æ–°æ–‡ä»¶';
            shareChineseStatus.className = 'file-status new';
        }

        if (status.bilingual_pdf_exists) {
            shareBilingualStatus.textContent = 'å·²å­˜åœ¨';
            shareBilingualStatus.className = 'file-status exists';
        } else {
            shareBilingualStatus.textContent = 'æ–°æ–‡ä»¶';
            shareBilingualStatus.className = 'file-status new';
        }

        // Show warning if any file exists
        if (status.chinese_pdf_exists || status.bilingual_pdf_exists) {
            shareWarning.style.display = 'flex';
        } else {
            shareWarning.style.display = 'none';
        }

        // Reset checkboxes
        shareChineseCheck.checked = true;
        shareBilingualCheck.checked = true;

        // Hide progress
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;

        // Show modal
        shareModal.classList.add('visible');
    } catch (error) {
        console.error('Failed to check share status:', error);
        showToast('æ£€æŸ¥åˆ†äº«çŠ¶æ€å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Close the share modal
 */
function closeShare() {
    shareModal.classList.remove('visible');
    currentShareArxivId = null; // Clear the stored arxivId
}

/**
 * Confirm and execute the share operation
 */
async function confirmShare() {
    const uploadChinese = shareChineseCheck.checked;
    const uploadBilingual = shareBilingualCheck.checked;

    if (!uploadChinese && !uploadBilingual) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ä¸Šä¼ ', 'warning');
        return;
    }

    // Show progress
    shareProgress.style.display = 'flex';
    btnShareConfirm.disabled = true;

    try {
        let result;

        // If we have a specific arxivId (from results list), use SharePaperToGitHub
        if (currentShareArxivId) {
            result = await SharePaperToGitHub(currentShareArxivId, uploadChinese, uploadBilingual);
        } else {
            // Otherwise use the current result (from main view)
            result = await ShareToGitHub(uploadChinese, uploadBilingual);
        }

        if (result.success) {
            closeShare();

            let message = 'åˆ†äº«æˆåŠŸï¼';
            if (result.chinese_pdf_url) {
                message += '\nä¸­æ–‡ PDF: ' + result.chinese_pdf_url;
            }
            if (result.bilingual_pdf_url) {
                message += '\nåŒè¯­ PDF: ' + result.bilingual_pdf_url;
            }

            showToast('åˆ†äº«æˆåŠŸ', 'success');
        } else {
            showToast(result.message || 'åˆ†äº«å¤±è´¥', 'error');
        }
    } catch (error) {
        console.error('Failed to share:', error);
        showToast('åˆ†äº«å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;
    }
}

/**
 * Update GitHub Token from remote
 */
async function updateGitHubToken() {
    githubUpdateStatus.textContent = 'â³ æ­£åœ¨è·å– Token...';
    githubUpdateStatus.className = 'test-status testing';
    btnUpdateGitHubToken.disabled = true;

    try {
        await UpdateGitHubToken();
        
        // Reload settings to show the new token
        const settings = await GetSettings();
        settingGitHubToken.value = settings.github_token || '';
        
        githubUpdateStatus.textContent = 'âœ… Token å·²æ›´æ–°';
        githubUpdateStatus.className = 'test-status success';
        showToast('GitHub Token å·²æˆåŠŸæ›´æ–°', 'success');
        
        // Clear status after 3 seconds
        setTimeout(() => {
            githubUpdateStatus.textContent = '';
            githubUpdateStatus.className = 'test-status';
        }, 3000);
    } catch (error) {
        console.error('Update GitHub token failed:', error);
        githubUpdateStatus.textContent = 'âŒ æ›´æ–°å¤±è´¥';
        githubUpdateStatus.className = 'test-status error';
        showToast('æ›´æ–° Token å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        btnUpdateGitHubToken.disabled = false;
    }
}

/**
 * Test GitHub connection
 */
async function testGitHubConnection() {
    const token = settingGitHubToken.value.trim();

    if (!token) {
        githubTestStatus.textContent = 'âŒ è¯·è¾“å…¥ GitHub Token';
        githubTestStatus.className = 'test-status error';
        return;
    }

    githubTestStatus.textContent = 'â³ æ­£åœ¨æµ‹è¯•...';
    githubTestStatus.className = 'test-status testing';
    btnTestGitHub.disabled = true;

    try {
        // Only pass token - owner and repo use defaults
        await TestGitHubConnection(token);
        githubTestStatus.textContent = 'âœ… è¿æ¥æˆåŠŸ';
        githubTestStatus.className = 'test-status success';
        showToast('GitHub è¿æ¥æµ‹è¯•æˆåŠŸ', 'success');
    } catch (error) {
        console.error('GitHub test failed:', error);
        githubTestStatus.textContent = 'âŒ ' + (error.message || 'è¿æ¥å¤±è´¥');
        githubTestStatus.className = 'test-status error';
        showToast('GitHub æµ‹è¯•å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        btnTestGitHub.disabled = false;
    }
}

/**
 * Perform startup environment check
 */
async function performStartupCheck() {
    console.log('Performing startup check...');

    // Reset UI to checking state
    resetStartupCheckUI();

    try {
        const result = await CheckStartupRequirements();
        console.log('Startup check result:', result);

        // Update LaTeX check result
        updateLatexCheckResult(result.latex_installed, result.latex_version);

        // Update LLM check result
        updateLlmCheckResult(result.llm_configured, result.llm_error);

        // Enable continue button if all checks pass
        btnContinue.disabled = !(result.latex_installed && result.llm_configured);

    } catch (error) {
        console.error('Startup check error:', error);
        // Show error state
        updateLatexCheckResult(false, 'æ£€æµ‹å¤±è´¥: ' + (error.message || error));
        updateLlmCheckResult(false, 'æ£€æµ‹å¤±è´¥');
    }
}

/**
 * Reset startup check UI to initial state
 */
function resetStartupCheckUI() {
    // Reset LaTeX check
    latexSpinner.style.display = 'inline-block';
    latexStatus.style.display = 'none';
    latexDetail.textContent = 'æ£€æµ‹ä¸­...';
    latexAction.style.display = 'none';
    checkLatexItem.classList.remove('success', 'error');

    // Reset LLM check
    llmSpinner.style.display = 'inline-block';
    llmStatus.style.display = 'none';
    llmDetail.textContent = 'æ£€æµ‹ä¸­...';
    llmAction.style.display = 'none';
    checkLlmItem.classList.remove('success', 'error');

    // Disable continue button
    btnContinue.disabled = true;
}

/**
 * Update LaTeX check result in UI
 */
function updateLatexCheckResult(installed, version) {
    latexSpinner.style.display = 'none';
    latexStatus.style.display = 'inline';

    if (installed) {
        latexStatus.textContent = 'âœ…';
        latexDetail.textContent = version || 'å·²å®‰è£…';
        checkLatexItem.classList.add('success');
        checkLatexItem.classList.remove('error');
        latexAction.style.display = 'none';
    } else {
        latexStatus.textContent = 'âŒ';
        latexDetail.textContent = 'æœªæ£€æµ‹åˆ° LaTeX ç¼–è¯‘å™¨';
        checkLatexItem.classList.add('error');
        checkLatexItem.classList.remove('success');
        latexAction.style.display = 'block';
    }
}

/**
 * Update LLM check result in UI
 */
function updateLlmCheckResult(configured, error) {
    llmSpinner.style.display = 'none';
    llmStatus.style.display = 'inline';

    if (configured) {
        llmStatus.textContent = 'âœ…';
        llmDetail.textContent = 'LLM é…ç½®æ­£ç¡®ï¼Œè¿æ¥æµ‹è¯•é€šè¿‡';
        checkLlmItem.classList.add('success');
        checkLlmItem.classList.remove('error');
        llmAction.style.display = 'none';
    } else {
        llmStatus.textContent = 'âŒ';
        llmDetail.textContent = error || 'LLM æœªé…ç½®æˆ–è¿æ¥å¤±è´¥';
        checkLlmItem.classList.add('error');
        checkLlmItem.classList.remove('success');
        llmAction.style.display = 'block';
    }
}

/**
 * Show startup check modal
 */
function showStartupCheckModal() {
    startupCheckModal.classList.add('visible');
}

/**
 * Close startup check modal
 */
function closeStartupCheckModal() {
    startupCheckModal.classList.remove('visible');
}

/**
 * Reset test status when LLM settings change
 * Only resets if the settings actually changed from the original values
 */
function resetTestStatus() {
    const currentApiKey = settingApiKey.value.trim();
    const currentBaseUrl = settingBaseUrl.value.trim();
    const currentModel = settingModel.value.trim();

    // Check if LLM settings have changed from original
    const llmChanged = (
        currentApiKey !== originalLlmSettings.apiKey ||
        currentBaseUrl !== originalLlmSettings.baseUrl ||
        currentModel !== originalLlmSettings.model
    );

    if (llmChanged) {
        apiTestPassed = false;
        testStatus.textContent = 'âš ï¸ é…ç½®å·²ä¿®æ”¹ï¼Œè¯·é‡æ–°æµ‹è¯•';
        testStatus.className = 'test-status warning';
    }
}

/**
 * Browse for work directory
 */
async function browseWorkdir() {
    try {
        const result = await OpenDirectoryDialog();
        if (result) {
            settingWorkdir.value = result;
        }
    } catch (error) {
        console.error('Error opening directory dialog:', error);
    }
}

/**
 * Test API connection
 */
async function testConnection() {
    const apiKey = settingApiKey.value.trim();
    const baseUrl = settingBaseUrl.value.trim();
    const model = settingModel.value.trim();

    // Validate required fields
    if (!apiKey) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥ API Key';
        testStatus.className = 'test-status error';
        return;
    }
    if (!baseUrl) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥ API Base URL';
        testStatus.className = 'test-status error';
        return;
    }
    if (!model) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥æ¨¡å‹åç§°';
        testStatus.className = 'test-status error';
        return;
    }

    // Show testing status
    testStatus.textContent = 'â³ æ­£åœ¨æµ‹è¯• LLM è¿æ¥...';
    testStatus.className = 'test-status testing';
    btnTestConnection.disabled = true;

    try {
        await TestAPIConnection(apiKey, baseUrl, model);
        testStatus.textContent = 'âœ… LLM æµ‹è¯•æˆåŠŸ';
        testStatus.className = 'test-status success';
        apiTestPassed = true;
        showToast('LLM è¿æ¥æµ‹è¯•æˆåŠŸ', 'success');
    } catch (error) {
        console.error('API test failed:', error);
        const errorMsg = error.message || error.toString() || 'è¿æ¥å¤±è´¥';
        testStatus.textContent = 'âŒ ' + errorMsg;
        testStatus.className = 'test-status error';
        apiTestPassed = false;
        showToast('LLM æµ‹è¯•å¤±è´¥: ' + errorMsg, 'error', 5000);
    } finally {
        btnTestConnection.disabled = false;
    }
}

/**
 * Save settings to backend
 */
async function saveSettings() {
    const apiKey = settingApiKey.value.trim();
    const baseUrl = settingBaseUrl.value.trim();
    const model = settingModel.value.trim();

    // Check if LLM settings have changed
    const llmChanged = (
        apiKey !== originalLlmSettings.apiKey ||
        baseUrl !== originalLlmSettings.baseUrl ||
        model !== originalLlmSettings.model
    );

    // Only require LLM test if LLM settings changed and test hasn't passed
    if (llmChanged && !apiTestPassed) {
        showToast('LLM é…ç½®å·²ä¿®æ”¹ï¼Œè¯·å…ˆæµ‹è¯•è¿æ¥', 'warning');
        return;
    }

    // If no API key at all, warn user
    if (!apiKey && !originalLlmSettings.apiKey) {
        showToast('è¯·é…ç½® LLM API Key', 'warning');
        return;
    }

    try {
        const contextWindow = parseInt(settingContextWindow.value) || 8192;
        const compiler = settingCompiler.value;
        const workDir = settingWorkdir.value.trim();
        const concurrency = parseInt(settingConcurrency.value) || 3;
        
        // Parse library page size, ensure it's at least 1
        let libraryPageSize = parseInt(settingLibraryPageSize.value);
        if (isNaN(libraryPageSize) || libraryPageSize < 1) {
            libraryPageSize = 20;
        }
        
        console.log('Saving settings with libraryPageSize:', libraryPageSize);

        // GitHub settings (use defaults for owner and repo)
        const githubToken = settingGitHubToken.value.trim();
        const githubOwner = DEFAULT_GITHUB_OWNER;
        const githubRepo = DEFAULT_GITHUB_REPO;

        // Save to backend
        await SaveSettings(apiKey, baseUrl, model, contextWindow, compiler, workDir, concurrency, githubToken, githubOwner, githubRepo, libraryPageSize);

        // Close modal
        closeSettings();

        // Show success message
        showToast('è®¾ç½®å·²ä¿å­˜', 'success');
    } catch (error) {
        console.error('Error saving settings:', error);
        showToast('ä¿å­˜è®¾ç½®å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Initialize the application
 */
async function init() {
    // Initialize DOM elements
    initElements();

    // Initialize backend bindings
    await initBindings();

    // Make showToast available globally for error management module
    window.showToast = showToast;

    // Initialize error management
    initErrorManagement({
        ListErrors,
        RetryFromError,
        ClearError,
        ClearAllErrors,
        ExportErrorsToFile,
        ExportErrorIDsToFile
    });

    // Set up event listeners
    setupEventListeners();

    // Perform startup environment check
    await performStartupCheckOnInit();

    // Load last input
    try {
        const lastInput = await GetLastInput();
        if (lastInput) {
            inputSource.value = lastInput;
        }
    } catch (error) {
        console.warn('Failed to load last input:', error);
    }

    // Set initial state
    updateStatus('idle', 0, 'å°±ç»ª');

    console.log('LaTeX ç¿»è¯‘å™¨å‰ç«¯å·²åˆå§‹åŒ–');
}

/**
 * Perform startup check on initialization
 * Shows modal if any check fails
 */
async function performStartupCheckOnInit() {
    try {
        const result = await CheckStartupRequirements();
        console.log('Initial startup check result:', result);

        // If any check fails, show the modal
        if (!result.latex_installed || !result.llm_configured) {
            showStartupCheckModal();

            // Update UI with results
            updateLatexCheckResult(result.latex_installed, result.latex_version);
            updateLlmCheckResult(result.llm_configured, result.llm_error);

            // Enable continue button if all checks pass
            btnContinue.disabled = !(result.latex_installed && result.llm_configured);
        }
    } catch (error) {
        console.error('Initial startup check error:', error);
        // Show modal with error state
        showStartupCheckModal();
        updateLatexCheckResult(false, 'æ£€æµ‹å¤±è´¥');
        updateLlmCheckResult(false, 'æ£€æµ‹å¤±è´¥');
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// ============================================
// PDF Translation Mode Functions
// ============================================

/**
 * Set up event listeners for PDF translation mode
 * Validates: Requirements 1.1, 1.2, 3.5, 5.5, 5.3, 5.6
 */
function setupPdfModeEventListeners() {
    // Mode tab switching
    if (modeTabLatex) {
        modeTabLatex.addEventListener('click', () => switchMode('latex'));
    }
    if (modeTabPdf) {
        modeTabPdf.addEventListener('click', () => switchMode('pdf'));
    }

    // PDF file selection button
    if (btnSelectPdf) {
        btnSelectPdf.addEventListener('click', handleSelectPdf);
    }

    // PDF drop zone drag and drop events
    if (pdfDropZone) {
        pdfDropZone.addEventListener('dragover', handlePdfDragOver);
        pdfDropZone.addEventListener('dragleave', handlePdfDragLeave);
        pdfDropZone.addEventListener('drop', handlePdfDrop);
        // Also allow clicking the drop zone to select file
        pdfDropZone.addEventListener('click', (e) => {
            // Don't trigger if clicking the button inside
            if (e.target !== btnSelectPdf && !btnSelectPdf.contains(e.target)) {
                handleSelectPdf();
            }
        });
    }

    // Clear selected PDF button
    if (btnClearPdf) {
        btnClearPdf.addEventListener('click', clearSelectedPdf);
    }

    // Start PDF translation button
    if (btnTranslatePdf) {
        btnTranslatePdf.addEventListener('click', handleTranslatePdf);
    }

    // Download translated PDF button
    // Validates: Requirements 5.6
    if (btnDownloadTranslated) {
        btnDownloadTranslated.addEventListener('click', handleDownloadTranslatedPdf);
    }

    // Set up sync scrolling between PDF iframes
    // Validates: Requirements 5.3
    setupPdfSyncScrolling();

    // Listen for PDF translation status updates
    EventsOn('pdf-status-update', handlePdfStatusUpdate);
}

/**
 * Switch between LaTeX and PDF translation modes
 * @param {string} mode - 'latex' or 'pdf'
 * Validates: Requirements 5.1
 */
function switchMode(mode) {
    if (mode === currentMode) return;

    // åˆ‡æ¢å‰ä¿å­˜å½“å‰æ¨¡å¼çš„ PDF è·¯å¾„ï¼ˆåªä¿å­˜æœ‰æ•ˆçš„ PDF è·¯å¾„ï¼‰
    if (currentMode === 'latex') {
        // ä¿å­˜ LaTeX æ¨¡å¼çš„ PDF è·¯å¾„
        const leftSrc = pdfLeftIframe.src;
        const rightSrc = pdfRightIframe.src;
        latexModeLeftPdf = (leftSrc && leftSrc !== 'about:blank' && leftSrc.includes('/pdf/')) ? leftSrc : null;
        latexModeRightPdf = (rightSrc && rightSrc !== 'about:blank' && rightSrc.includes('/pdf/')) ? rightSrc : null;
    } else {
        // ä¿å­˜ PDF æ¨¡å¼çš„ PDF è·¯å¾„
        const leftSrc = pdfLeftIframe.src;
        const rightSrc = pdfRightIframe.src;
        pdfModeLeftPdf = (leftSrc && leftSrc !== 'about:blank' && leftSrc.includes('/pdf/')) ? leftSrc : null;
        pdfModeRightPdf = (rightSrc && rightSrc !== 'about:blank' && rightSrc.includes('/pdf/')) ? rightSrc : null;
    }

    currentMode = mode;

    // Update tab active states
    if (modeTabLatex && modeTabPdf) {
        modeTabLatex.classList.toggle('active', mode === 'latex');
        modeTabPdf.classList.toggle('active', mode === 'pdf');
    }

    // Show/hide input sections
    if (latexInputSection && pdfInputSection) {
        latexInputSection.style.display = mode === 'latex' ? 'flex' : 'none';
        pdfInputSection.classList.toggle('visible', mode === 'pdf');
    }

    // æ¢å¤ç›®æ ‡æ¨¡å¼çš„ PDF è·¯å¾„
    if (mode === 'latex') {
        restoreLatexModeState();
    } else {
        restorePdfModeState();
    }
}

/**
 * æ¢å¤ LaTeX æ¨¡å¼çš„çŠ¶æ€
 */
function restoreLatexModeState() {
    // æ¢å¤çŠ¶æ€æ 
    applyStatusDisplay(latexModeStatus);

    // æ¢å¤è¿›åº¦æ¡å¯è§æ€§
    if (isProcessing) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }

    // æ¢å¤å·¦ä¾§ PDF
    if (latexModeLeftPdf) {
        pdfLeftPlaceholder.style.display = 'none';
        pdfLeftIframe.style.display = 'block';
        pdfLeftIframe.src = latexModeLeftPdf;
    } else {
        pdfLeftIframe.src = 'about:blank';
        pdfLeftIframe.style.display = 'none';
        pdfLeftPlaceholder.style.display = 'flex';
    }

    // æ¢å¤å³ä¾§ PDF
    if (latexModeRightPdf) {
        pdfRightPlaceholder.style.display = 'none';
        pdfRightIframe.style.display = 'block';
        pdfRightIframe.src = latexModeRightPdf;
    } else {
        pdfRightIframe.src = 'about:blank';
        pdfRightIframe.style.display = 'none';
        pdfRightPlaceholder.style.display = 'flex';
    }

    // æ¢å¤ä¸‹è½½æŒ‰é’®çŠ¶æ€
    if (currentResult) {
        downloadDropdown.style.display = 'inline-block';
        btnShare.style.display = 'inline-block';
    } else {
        downloadDropdown.style.display = 'none';
        btnShare.style.display = 'none';
    }
    hideDownloadTranslatedButton();
}

/**
 * æ¢å¤ PDF æ¨¡å¼çš„çŠ¶æ€
 */
function restorePdfModeState() {
    // æ¢å¤çŠ¶æ€æ 
    applyStatusDisplay(pdfModeStatus);

    // æ¢å¤è¿›åº¦æ¡å¯è§æ€§
    if (isPdfTranslating) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }

    // éšè— LaTeX æ¨¡å¼çš„ä¸‹è½½æŒ‰é’®
    downloadDropdown.style.display = 'none';
    btnShare.style.display = 'none';

    // æ¢å¤å·¦ä¾§ PDF
    if (pdfModeLeftPdf) {
        pdfLeftPlaceholder.style.display = 'none';
        pdfLeftIframe.style.display = 'block';
        pdfLeftIframe.src = pdfModeLeftPdf;
    } else {
        pdfLeftIframe.src = 'about:blank';
        pdfLeftIframe.style.display = 'none';
        pdfLeftPlaceholder.style.display = 'flex';
    }

    // æ¢å¤å³ä¾§ PDF
    if (pdfModeRightPdf) {
        pdfRightPlaceholder.style.display = 'none';
        pdfRightIframe.style.display = 'block';
        pdfRightIframe.src = pdfModeRightPdf;
        showDownloadTranslatedButton(pdfModeRightPdf.replace('/pdf/', ''));
    } else {
        pdfRightIframe.src = 'about:blank';
        pdfRightIframe.style.display = 'none';
        pdfRightPlaceholder.style.display = 'flex';
        hideDownloadTranslatedButton();
    }

    // æ¢å¤æ–‡ä»¶é€‰æ‹©åŒºåŸŸçŠ¶æ€
    if (currentPdfFilePath && currentPdfInfo) {
        showSelectedPdfFile(currentPdfInfo);
    } else {
        if (pdfFileSelected) {
            pdfFileSelected.classList.remove('visible');
        }
        if (pdfDropZone) {
            pdfDropZone.style.display = 'block';
        }
    }
}

/**
 * Handle PDF file selection via dialog
 * Validates: Requirements 1.1
 */
async function handleSelectPdf() {
    try {
        const filePath = await OpenPDFFileDialog();
        if (filePath) {
            await loadPdfFile(filePath);
        }
    } catch (error) {
        console.error('Error selecting PDF file:', error);
        showError('é€‰æ‹© PDF æ–‡ä»¶å¤±è´¥: ' + (error.message || error));
    }
}

/**
 * Handle drag over event for PDF drop zone
 * @param {DragEvent} e - Drag event
 * Validates: Requirements 1.2
 */
function handlePdfDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.add('drag-over');
}

/**
 * Handle drag leave event for PDF drop zone
 * @param {DragEvent} e - Drag event
 * Validates: Requirements 1.2
 */
function handlePdfDragLeave(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.remove('drag-over');
}

/**
 * Handle drop event for PDF drop zone
 * @param {DragEvent} e - Drop event
 * Validates: Requirements 1.2
 */
async function handlePdfDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.remove('drag-over');

    const files = e.dataTransfer.files;
    if (files.length === 0) {
        return;
    }

    const file = files[0];

    // Check if it's a PDF file
    if (!file.name.toLowerCase().endsWith('.pdf')) {
        showError('è¯·é€‰æ‹© PDF æ–‡ä»¶');
        return;
    }

    // For drag and drop, we need to get the file path
    // In Wails, we can use the file path from the dataTransfer
    // However, web browsers don't expose the full path for security reasons
    // We need to use the Wails file dialog instead
    showToast('æ‹–æ‹½åŠŸèƒ½æš‚ä¸æ”¯æŒï¼Œè¯·ä½¿ç”¨"é€‰æ‹© PDF æ–‡ä»¶"æŒ‰é’®', 'warning');
}

/**
 * Load a PDF file and display its info
 * @param {string} filePath - Path to the PDF file
 * Validates: Requirements 1.1, 1.4
 */
async function loadPdfFile(filePath) {
    try {
        updateStatus('loading', 0, 'æ­£åœ¨åŠ è½½ PDF æ–‡ä»¶...');

        // Call backend to load PDF
        const pdfInfo = await LoadPDF(filePath);

        if (!pdfInfo) {
            throw new Error('æ— æ³•åŠ è½½ PDF æ–‡ä»¶');
        }

        // Check if it's a text PDF
        if (!pdfInfo.is_text_pdf) {
            showError('è¯¥ PDF ä¸ºæ‰«æä»¶ï¼Œä¸æ”¯æŒç›´æ¥ç¿»è¯‘');
            updateStatus('error', 0, 'ä¸æ”¯æŒçš„ PDF æ ¼å¼');
            return;
        }

        // Store the PDF info and path
        currentPdfInfo = pdfInfo;
        currentPdfFilePath = filePath;

        // Update UI to show selected file
        showSelectedPdfFile(pdfInfo);

        // Load the original PDF in the left viewer
        loadPDF('left', filePath);

        updateStatus('idle', 0, 'PDF æ–‡ä»¶å·²åŠ è½½ï¼Œå¯ä»¥å¼€å§‹ç¿»è¯‘');
        showToast(`å·²åŠ è½½: ${pdfInfo.file_name} (${pdfInfo.page_count} é¡µ)`, 'success');

    } catch (error) {
        console.error('Error loading PDF:', error);
        showError('åŠ è½½ PDF å¤±è´¥: ' + (error.message || error));
        updateStatus('error', 0, 'åŠ è½½å¤±è´¥');
    }
}

/**
 * Show selected PDF file info in the UI
 * @param {Object} pdfInfo - PDF file information
 * Validates: Requirements 1.4
 */
function showSelectedPdfFile(pdfInfo) {
    if (!pdfFileSelected || !pdfFileName || !pdfFileSize) return;

    // Update file info display
    pdfFileName.textContent = pdfInfo.file_name || 'Unknown';
    pdfFileSize.textContent = formatFileSize(pdfInfo.file_size) + ` Â· ${pdfInfo.page_count} é¡µ`;

    // Show the selected file container, hide drop zone
    pdfFileSelected.classList.add('visible');
    if (pdfDropZone) {
        pdfDropZone.style.display = 'none';
    }
}

/**
 * Clear the selected PDF file
 */
function clearSelectedPdf() {
    currentPdfInfo = null;
    currentPdfFilePath = null;
    currentPdfTranslatedPath = null; // æ¸…é™¤ç¿»è¯‘åçš„ PDF è·¯å¾„

    // Hide selected file container, show drop zone
    if (pdfFileSelected) {
        pdfFileSelected.classList.remove('visible');
    }
    if (pdfDropZone) {
        pdfDropZone.style.display = 'block';
    }

    // Reset PDF viewers
    resetPDFViewers();

    // Hide download button
    hideDownloadTranslatedButton();

    // Reset status
    updateStatus('idle', 0, 'å°±ç»ª');
}

/**
 * Format file size to human readable string
 * @param {number} bytes - File size in bytes
 * @returns {string} Formatted file size
 */
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Handle PDF translation button click
 * Validates: Requirements 3.5, 5.5, 5.6
 */
async function handleTranslatePdf() {
    if (!currentPdfFilePath) {
        showError('è¯·å…ˆé€‰æ‹© PDF æ–‡ä»¶');
        return;
    }

    if (isPdfTranslating) {
        return;
    }

    // Update UI to translating state
    setPdfTranslatingState(true);
    updateStatus('translating', 0, 'å¼€å§‹ç¿»è¯‘...');

    // Hide download button while translating
    hideDownloadTranslatedButton();

    try {
        // Start status polling
        startPdfStatusPolling();

        // Call backend to start translation
        const result = await TranslatePDF();

        // Stop status polling
        stopPdfStatusPolling();

        if (result) {
            // Translation completed successfully
            updateStatus('complete', 100, 'ç¿»è¯‘å®Œæˆ');

            // Load translated PDF in the right viewer
            if (result.translated_pdf_path) {
                // ä¿å­˜ç¿»è¯‘åçš„ PDF è·¯å¾„ï¼Œç”¨äºæ¨¡å¼åˆ‡æ¢æ—¶æ¢å¤
                currentPdfTranslatedPath = result.translated_pdf_path;
                loadPDF('right', result.translated_pdf_path);
                // Show download button for translated PDF
                // Validates: Requirements 5.6
                showDownloadTranslatedButton(result.translated_pdf_path);
            }

            showToast(`ç¿»è¯‘å®Œæˆï¼å…±ç¿»è¯‘ ${result.translated_blocks} ä¸ªæ–‡æœ¬å—`, 'success');
        }
    } catch (error) {
        console.error('PDF translation error:', error);
        stopPdfStatusPolling();

        const errorMsg = error.message || error.toString() || 'ç¿»è¯‘å¤±è´¥';
        updateStatus('error', 0, errorMsg);
        showError(errorMsg);
    } finally {
        setPdfTranslatingState(false);
    }
}

/**
 * Handle PDF status update from backend event
 * @param {Object} status - PDF status object from backend
 * Validates: Requirements 3.5, 5.5
 */
function handlePdfStatusUpdate(status) {
    if (status) {
        updatePdfStatus(status);
    }
}

/**
 * Update the PDF translation status display
 * @param {Object} status - PDF status object
 * Validates: Requirements 3.5, 5.5
 */
function updatePdfStatus(status) {
    const phase = status.phase || 'idle';
    const progress = status.progress || 0;
    let message = status.message || '';

    // Add block progress info if available
    if (status.total_blocks > 0) {
        message = `${message} (${status.completed_blocks}/${status.total_blocks} å—)`;
    }

    updateStatus(phase, progress, message, status.error);
}

/**
 * Start polling for PDF translation status
 * Validates: Requirements 3.5, 5.5
 */
function startPdfStatusPolling() {
    // Poll every 500ms
    pdfStatusPollInterval = setInterval(async () => {
        try {
            const status = await GetPDFStatus();
            if (status) {
                updatePdfStatus(status);
            }
        } catch (error) {
            console.error('PDF status poll error:', error);
        }
    }, 500);
}

/**
 * Stop polling for PDF translation status
 */
function stopPdfStatusPolling() {
    if (pdfStatusPollInterval) {
        clearInterval(pdfStatusPollInterval);
        pdfStatusPollInterval = null;
    }
}

/**
 * Update UI to reflect PDF translating state
 * @param {boolean} translating - Whether translation is in progress
 */
function setPdfTranslatingState(translating) {
    isPdfTranslating = translating;

    // Update translate button state
    if (btnTranslatePdf) {
        btnTranslatePdf.disabled = translating;
        btnTranslatePdf.textContent = translating ? 'â³ ç¿»è¯‘ä¸­...' : 'ğŸš€ å¼€å§‹ç¿»è¯‘';
    }

    // Update clear button state
    if (btnClearPdf) {
        btnClearPdf.disabled = translating;
    }

    // Update progress container visibility
    if (progressContainer) {
        if (translating) {
            progressContainer.classList.add('visible');
        } else {
            progressContainer.classList.remove('visible');
        }
    }
}

/**
 * Cancel PDF translation
 */
async function handleCancelPdfTranslation() {
    try {
        await CancelPDFTranslation();
        stopPdfStatusPolling();
        updateStatus('idle', 0, 'ç¿»è¯‘å·²å–æ¶ˆ');
        setPdfTranslatingState(false);
        showToast('ç¿»è¯‘å·²å–æ¶ˆ', 'info');
    } catch (error) {
        console.error('Cancel PDF translation error:', error);
        showError('å–æ¶ˆç¿»è¯‘å¤±è´¥');
    }
}

/**
 * Set up sync scrolling between the two PDF iframes
 * When one PDF is scrolled, the other follows to the same relative position
 * Validates: Requirements 5.3
 */
function setupPdfSyncScrolling() {
    // We need to wait for iframes to load before setting up scroll listeners
    // The scroll sync is set up when PDFs are loaded via the loadPDF function

    if (pdfLeftIframe) {
        pdfLeftIframe.addEventListener('load', () => {
            setupIframeSyncScroll(pdfLeftIframe, pdfRightIframe, 'left');
        });
    }

    if (pdfRightIframe) {
        pdfRightIframe.addEventListener('load', () => {
            setupIframeSyncScroll(pdfRightIframe, pdfLeftIframe, 'right');
        });
    }
}

/**
 * Set up scroll sync for a specific iframe
 * @param {HTMLIFrameElement} sourceIframe - The iframe that triggers the scroll
 * @param {HTMLIFrameElement} targetIframe - The iframe that should follow
 * @param {string} side - 'left' or 'right' for debugging
 * Validates: Requirements 5.3
 */
function setupIframeSyncScroll(sourceIframe, targetIframe, side) {
    try {
        // Try to access the iframe's content window
        const sourceWindow = sourceIframe.contentWindow;
        if (!sourceWindow) {
            console.warn(`Cannot access ${side} iframe content window`);
            return;
        }

        // Add scroll event listener to the source iframe
        sourceWindow.addEventListener('scroll', () => {
            // Prevent infinite scroll loop
            if (isSyncScrolling) return;

            try {
                const targetWindow = targetIframe.contentWindow;
                if (!targetWindow) return;

                // Get scroll position as percentage
                const sourceDoc = sourceWindow.document.documentElement || sourceWindow.document.body;
                const targetDoc = targetWindow.document.documentElement || targetWindow.document.body;

                if (!sourceDoc || !targetDoc) return;

                const sourceScrollHeight = sourceDoc.scrollHeight - sourceDoc.clientHeight;
                const targetScrollHeight = targetDoc.scrollHeight - targetDoc.clientHeight;

                if (sourceScrollHeight <= 0 || targetScrollHeight <= 0) return;

                // Calculate scroll percentage
                const scrollPercentage = sourceWindow.scrollY / sourceScrollHeight;

                // Apply to target
                isSyncScrolling = true;
                targetWindow.scrollTo({
                    top: scrollPercentage * targetScrollHeight,
                    behavior: 'auto' // Use 'auto' for immediate sync, 'smooth' for animated
                });

                // Reset flag after a short delay
                setTimeout(() => {
                    isSyncScrolling = false;
                }, 50);

            } catch (e) {
                // Cross-origin restrictions may prevent access
                console.debug('Sync scroll error (may be cross-origin):', e.message);
            }
        });

        console.log(`Sync scroll set up for ${side} iframe`);

    } catch (e) {
        // Cross-origin restrictions may prevent access
        console.debug(`Cannot set up sync scroll for ${side} iframe:`, e.message);
    }
}

/**
 * Handle download translated PDF button click
 * Validates: Requirements 5.6
 */
async function handleDownloadTranslatedPdf() {
    if (!translatedPdfPath) {
        showToast('æ²¡æœ‰å¯ä¸‹è½½çš„ç¿»è¯‘ PDF', 'warning');
        return;
    }

    try {
        showToast('æ­£åœ¨å‡†å¤‡ä¸‹è½½...', 'info');

        // Use the GetTranslatedPDFPath to get the path and trigger download
        // The backend should handle saving the file to user's chosen location
        const savePath = await GetTranslatedPDFPath();

        if (savePath) {
            showToast('ç¿»è¯‘å PDF å·²ä¿å­˜', 'success');
        }
    } catch (error) {
        console.error('Download translated PDF error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Show the download button for translated PDF
 * @param {string} pdfPath - Path to the translated PDF
 * Validates: Requirements 5.6
 */
function showDownloadTranslatedButton(pdfPath) {
    translatedPdfPath = pdfPath;
    if (btnDownloadTranslated) {
        btnDownloadTranslated.style.display = 'flex';
    }
}

/**
 * Hide the download button for translated PDF
 */
function hideDownloadTranslatedButton() {
    translatedPdfPath = null;
    if (btnDownloadTranslated) {
        btnDownloadTranslated.style.display = 'none';
    }
}

/**
 * Handle arXiv search button click
 * Searches for existing translations on GitHub
 * If not found, validates the arXiv ID and offers to translate
 */
async function handleArxivSearch() {
    const arxivId = arxivSearchInput.value.trim();

    if (!arxivId) {
        showToast('è¯·è¾“å…¥ arXiv ID', 'warning');
        return;
    }

    // Disable button during search
    btnArxivSearch.disabled = true;
    btnArxivSearch.textContent = 'æœç´¢ä¸­...';

    try {
        showToast('æ­£åœ¨ GitHub æœç´¢å·²ç¿»è¯‘è®ºæ–‡...', 'info');

        // Search GitHub
        const searchResult = await SearchGitHubTranslation(arxivId);

        if (!searchResult || !searchResult.found) {
            // Not found on GitHub, validate if it's a valid arXiv ID
            showToast(`æœªæ‰¾åˆ° ${arxivId} çš„ç¿»è¯‘ï¼Œæ­£åœ¨éªŒè¯ arXiv ID...`, 'info');
            
            try {
                // Validate arXiv ID by fetching metadata from arXiv
                const metadata = await GetArxivPaperMetadata(arxivId);
                
                if (metadata && metadata.title) {
                    // Valid arXiv ID, show custom confirm dialog
                    showTranslateConfirmModal(arxivId, metadata);
                } else {
                    showToast(`"${arxivId}" ä¸æ˜¯æœ‰æ•ˆçš„ arXiv ID`, 'warning');
                }
            } catch (validationError) {
                console.error('arXiv validation error:', validationError);
                showToast(`"${arxivId}" ä¸æ˜¯æœ‰æ•ˆçš„ arXiv ID æˆ–æ— æ³•è®¿é—® arXiv`, 'warning');
            }
            return;
        }

        // Found translation! Show download options
        showArxivSearchResultDialog(arxivId, searchResult);

    } catch (error) {
        console.error('GitHub search error:', error);
        showToast('æœç´¢å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        // Re-enable button
        btnArxivSearch.disabled = false;
        btnArxivSearch.innerHTML = '<span class="search-icon">ğŸ”</span>æœç´¢';
    }
}

/**
 * Show translate confirm modal
 * @param {string} arxivId - arXiv ID
 * @param {object} metadata - Paper metadata from arXiv
 */
function showTranslateConfirmModal(arxivId, metadata) {
    // Store the arXiv ID for later use
    pendingTranslateArxivId = arxivId;
    
    // Update modal content
    previewArxivId.textContent = arxivId;
    previewTitle.textContent = metadata.title || '-';
    previewAuthors.textContent = metadata.authors || '-';
    
    // Show modal
    translateConfirmModal.classList.add('visible');
}

/**
 * Close translate confirm modal
 */
function closeTranslateConfirmModal() {
    translateConfirmModal.classList.remove('visible');
    pendingTranslateArxivId = null;
}

/**
 * Confirm translation - start the translation process
 */
function confirmTranslate() {
    if (!pendingTranslateArxivId) {
        closeTranslateConfirmModal();
        return;
    }
    
    // Set the input and close modal
    inputSource.value = pendingTranslateArxivId;
    closeTranslateConfirmModal();
    
    // Start translation
    handleProcess();
}

/**
 * Show search result dialog with download options
 * @param {string} arxivId - arXiv ID
 * @param {object} searchResult - Search result from GitHub
 */
function showArxivSearchResultDialog(arxivId, searchResult) {
    // Store current download data
    currentDownloadData = {
        arxivId: arxivId,
        searchResult: searchResult
    };

    // Set arXiv ID display
    downloadArxivId.textContent = `arXiv: ${arxivId}`;

    // Reset all checkboxes and hide all items
    downloadChineseItem.style.display = 'none';
    downloadBilingualItem.style.display = 'none';
    downloadLatexItem.style.display = 'none';
    downloadChineseCheck.checked = true;
    downloadBilingualCheck.checked = true;
    downloadLatexCheck.checked = true;

    // Show available files
    if (searchResult.chinese_pdf) {
        downloadChineseItem.style.display = 'flex';
        downloadChineseName.textContent = searchResult.chinese_pdf_filename || `${arxivId}_cn.pdf`;
    }

    if (searchResult.bilingual_pdf) {
        downloadBilingualItem.style.display = 'flex';
        downloadBilingualName.textContent = searchResult.bilingual_pdf_filename || `${arxivId}_bilingual.pdf`;
    }

    if (searchResult.latex_zip) {
        downloadLatexItem.style.display = 'flex';
        downloadLatexName.textContent = searchResult.latex_zip_filename || `${arxivId}_latex.zip`;
    }

    // Hide progress
    downloadProgress.style.display = 'none';

    // Show modal
    githubDownloadModal.classList.add('visible');

    // Show success toast
    showToast(`æ‰¾åˆ° ${arxivId} çš„ç¿»è¯‘ï¼`, 'success', 3000);
}

/**
 * Close download modal
 */
function closeDownloadModal() {
    githubDownloadModal.classList.remove('visible');
    currentDownloadData = null;
}

/**
 * Confirm download - download selected files
 */
async function confirmDownload() {
    if (!currentDownloadData) {
        return;
    }

    const { arxivId, searchResult } = currentDownloadData;

    // Collect selected files
    const selectedFiles = [];

    if (downloadChineseItem.style.display !== 'none' && downloadChineseCheck.checked) {
        selectedFiles.push({ type: 'chinese', label: 'ä¸­æ–‡ PDF' });
    }

    if (downloadBilingualItem.style.display !== 'none' && downloadBilingualCheck.checked) {
        selectedFiles.push({ type: 'bilingual', label: 'åŒè¯­å¯¹ç…§ PDF' });
    }

    if (downloadLatexItem.style.display !== 'none' && downloadLatexCheck.checked) {
        selectedFiles.push({ type: 'latex', label: 'LaTeX æºç ' });
    }

    if (selectedFiles.length === 0) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶', 'warning');
        return;
    }

    // Disable buttons and show progress
    btnDownloadConfirm.disabled = true;
    btnDownloadCancel.disabled = true;
    downloadProgress.style.display = 'flex';

    try {
        // Let user select save directory
        const saveDir = await OpenDirectoryDialog();

        if (!saveDir) {
            showToast('å·²å–æ¶ˆä¸‹è½½', 'info');
            closeDownloadModal();
            return;
        }

        let downloadedCount = 0;
        let chinesePdfPath = null;
        let bilingualPdfPath = null;

        // Download each selected file
        for (const file of selectedFiles) {
            try {
                downloadProgressText.textContent = `æ­£åœ¨ä¸‹è½½ ${file.label}...`;
                const savedPath = await DownloadGitHubTranslation(arxivId, file.type, saveDir);

                if (savedPath) {
                    console.log(`Downloaded ${file.label} to:`, savedPath);
                    downloadedCount++;

                    // Remember the PDF paths for loading
                    if (file.type === 'chinese') {
                        chinesePdfPath = savedPath;
                    } else if (file.type === 'bilingual') {
                        bilingualPdfPath = savedPath;
                    }
                }
            } catch (error) {
                console.error(`Failed to download ${file.label}:`, error);
                showToast(`ä¸‹è½½ ${file.label} å¤±è´¥: ${error.message || error}`, 'error');
            }
        }

        if (downloadedCount > 0) {
            showToast(`æˆåŠŸä¸‹è½½ ${downloadedCount} ä¸ªæ–‡ä»¶`, 'success', 5000);

            // Load PDFs in viewer
            // Priority: bilingual PDF on left (original position), Chinese PDF on right
            if (bilingualPdfPath) {
                try {
                    loadPDF('left', bilingualPdfPath);
                    console.log('Loaded bilingual PDF on left:', bilingualPdfPath);
                } catch (e) {
                    console.warn('Could not load bilingual PDF in viewer:', e);
                }
            }
            
            if (chinesePdfPath) {
                try {
                    loadPDF('right', chinesePdfPath);
                    console.log('Loaded Chinese PDF on right:', chinesePdfPath);
                } catch (e) {
                    console.warn('Could not load Chinese PDF in viewer:', e);
                }
            }
        } else {
            showToast('æ²¡æœ‰æ–‡ä»¶è¢«ä¸‹è½½', 'warning');
        }

        // Close modal
        closeDownloadModal();

    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        // Re-enable buttons and hide progress
        btnDownloadConfirm.disabled = false;
        btnDownloadCancel.disabled = false;
        downloadProgress.style.display = 'none';
    }
}

/**
 * Download translation files from GitHub
 * @param {string} arxivId - arXiv ID
 * @param {Array} availableFiles - Array of available file types
 * @param {object} searchResult - Search result
 */
async function downloadGitHubTranslation(arxivId, availableFiles, searchResult) {
    try {
        // Let user select save directory
        const saveDir = await OpenDirectoryDialog();

        if (!saveDir) {
            showToast('å·²å–æ¶ˆä¸‹è½½', 'info');
            return;
        }

        showToast('å¼€å§‹ä¸‹è½½...', 'info');
        let downloadedCount = 0;
        let chinesePdfFilename = null;

        // Download each available file
        for (const file of availableFiles) {
            try {
                showToast(`æ­£åœ¨ä¸‹è½½ ${file.label}...`, 'info');
                const savedPath = await DownloadGitHubTranslation(arxivId, file.type, saveDir);

                if (savedPath) {
                    console.log(`Downloaded ${file.label} to:`, savedPath);
                    downloadedCount++;

                    // Remember the Chinese PDF filename for loading
                    if (file.type === 'chinese') {
                        // Extract filename from full path
                        const pathParts = savedPath.split('\\');
                        chinesePdfFilename = pathParts[pathParts.length - 1];
                    }
                }
            } catch (error) {
                console.error(`Failed to download ${file.label}:`, error);
                showToast(`ä¸‹è½½ ${file.label} å¤±è´¥: ${error.message || error}`, 'error');
            }
        }

        if (downloadedCount > 0) {
            showToast(`æˆåŠŸä¸‹è½½ ${downloadedCount} ä¸ªæ–‡ä»¶åˆ° ${saveDir}`, 'success', 5000);

            // Optionally, load PDFs if they were downloaded
            if (chinesePdfFilename) {
                const chinesePdfPath = `${saveDir}\\${chinesePdfFilename}`;
                try {
                    // Try to load the Chinese PDF in the viewer
                    loadPDF('right', chinesePdfPath);
                } catch (e) {
                    console.warn('Could not load downloaded PDF in viewer:', e);
                }
            }
        } else {
            showToast('æ²¡æœ‰æ–‡ä»¶è¢«ä¸‹è½½', 'warning');
        }

    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Open browse library modal and load recent translations
 */
async function openBrowseLibrary() {
    // Show modal
    browseLibraryModal.classList.add('visible');

    // Show loading state
    libraryLoading.style.display = 'block';
    libraryContent.style.display = 'none';
    libraryEmpty.style.display = 'none';

    try {
        // Load page size from settings
        const settings = await GetSettings();
        console.log('Loaded settings:', settings);
        console.log('Library page size from settings:', settings?.library_page_size);
        
        if (settings && settings.library_page_size > 0) {
            pageSize = settings.library_page_size;
            console.log('Using page size from settings:', pageSize);
        } else {
            console.log('Using default page size:', pageSize);
        }

        // Fetch all translations from GitHub (up to 1000)
        const papers = await ListRecentGitHubTranslations(1000);

        if (!papers || papers.length === 0) {
            libraryLoading.style.display = 'none';
            libraryEmpty.style.display = 'block';
            return;
        }

        // Store all papers
        allPapers = papers;
        currentPage = 1;
        totalPages = Math.ceil(allPapers.length / pageSize);

        // Update total papers count
        totalPapersSpan.textContent = allPapers.length;

        // Render first page
        renderCurrentPage();

        // Show content
        libraryLoading.style.display = 'none';
        libraryContent.style.display = 'flex';

    } catch (error) {
        console.error('Failed to load library:', error);
        showToast('åŠ è½½å…±äº«åº“å¤±è´¥: ' + (error.message || error), 'error');
        libraryLoading.style.display = 'none';
        libraryEmpty.style.display = 'block';
    }
}

/**
 * Render current page of papers
 */
function renderCurrentPage() {
    // Clear existing list
    libraryList.innerHTML = '';

    // Calculate start and end indices
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, allPapers.length);

    // Get papers for current page
    const pagePapers = allPapers.slice(startIndex, endIndex);

    // Render each paper
    for (const paper of pagePapers) {
        renderLibraryPaperItem(paper);
    }

    // Update pagination UI
    updatePaginationUI();

    // Scroll to top of list
    libraryList.scrollTop = 0;
}

/**
 * Update pagination UI
 */
function updatePaginationUI() {
    // Update page numbers
    currentPageSpan.textContent = currentPage;
    totalPagesSpan.textContent = totalPages;

    // Update button states
    btnFirstPage.disabled = currentPage === 1;
    btnPrevPage.disabled = currentPage === 1;
    btnNextPage.disabled = currentPage === totalPages;
    btnLastPage.disabled = currentPage === totalPages;
}

/**
 * Go to specific page
 * @param {number} page - Page number (1-based)
 */
function goToPage(page) {
    if (page < 1 || page > totalPages || page === currentPage) {
        return;
    }

    currentPage = page;
    renderCurrentPage();
}

/**
 * Close browse library modal
 */
function closeBrowseLibrary() {
    browseLibraryModal.classList.remove('visible');
}

/**
 * Render a library paper item
 * @param {object} paper - Paper info from GitHub
 */
function renderLibraryPaperItem(paper) {
    const item = document.createElement('div');
    item.className = 'library-paper-item';
    item.dataset.arxivId = paper.arxiv_id;

    // Create paper header with arXiv ID
    const header = document.createElement('div');
    header.className = 'library-paper-header';

    const arxivId = document.createElement('span');
    arxivId.className = 'library-paper-arxiv';
    arxivId.textContent = paper.arxiv_id;
    header.appendChild(arxivId);

    item.appendChild(header);

    // Create title placeholder
    const title = document.createElement('div');
    title.className = 'library-paper-title';
    title.textContent = 'åŠ è½½ä¸­...';
    item.appendChild(title);

    // Create file badges
    const filesDiv = document.createElement('div');
    filesDiv.className = 'library-paper-files';

    if (paper.has_chinese) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“„</span> ä¸­æ–‡PDF';
        filesDiv.appendChild(badge);
    }

    if (paper.has_bilingual) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“‘</span> åŒè¯­PDF';
        filesDiv.appendChild(badge);
    }

    if (paper.has_latex) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“¦</span> LaTeX';
        filesDiv.appendChild(badge);
    }

    item.appendChild(filesDiv);

    // Create abstract tooltip (will be populated when metadata is loaded)
    const abstractDiv = document.createElement('div');
    abstractDiv.className = 'library-paper-abstract';
    abstractDiv.style.display = 'none';
    item.appendChild(abstractDiv);

    // Add mouse enter/leave handlers for abstract positioning
    item.addEventListener('mouseenter', () => {
        if (abstractDiv.innerHTML) {
            const rect = item.getBoundingClientRect();
            const abstractHeight = 250; // Approximate height
            
            // Position above the item
            abstractDiv.style.left = rect.left + 'px';
            abstractDiv.style.width = Math.min(600, rect.width) + 'px';
            
            // Check if there's enough space above
            if (rect.top > abstractHeight + 20) {
                abstractDiv.style.top = (rect.top - abstractHeight - 10) + 'px';
                abstractDiv.style.bottom = 'auto';
            } else {
                // Position below if not enough space above
                abstractDiv.style.top = (rect.bottom + 10) + 'px';
                abstractDiv.style.bottom = 'auto';
            }
        }
    });

    item.addEventListener('mouseleave', () => {
        // Reset positioning
        abstractDiv.style.display = 'none';
    });

    // Add click handler to download
    item.addEventListener('click', () => {
        handleLibraryPaperClick(paper);
    });

    // Add to list
    libraryList.appendChild(item);

    // Fetch metadata asynchronously
    fetchPaperMetadata(paper.arxiv_id, item, title, abstractDiv);
}

/**
 * Fetch paper metadata from arXiv and update UI
 * @param {string} arxivId - arXiv ID
 * @param {HTMLElement} item - Paper item element
 * @param {HTMLElement} titleElement - Title element
 * @param {HTMLElement} abstractElement - Abstract element
 */
async function fetchPaperMetadata(arxivId, item, titleElement, abstractElement) {
    try {
        const metadata = await GetArxivPaperMetadata(arxivId);

        if (metadata && metadata.title) {
            // Update title
            titleElement.textContent = metadata.title;

            // Update abstract tooltip
            if (metadata.abstract) {
                abstractElement.innerHTML = `
                    <div class="library-abstract-title">æ‘˜è¦</div>
                    <div class="library-abstract-content">${metadata.abstract}</div>
                `;
                // Don't set display here, let hover event handle it
            }
        }
    } catch (error) {
        console.warn(`Failed to fetch metadata for ${arxivId}:`, error);
        titleElement.textContent = arxivId; // Fallback to arXiv ID
    }
}

/**
 * Handle library paper item click - trigger download
 * @param {object} paper - Paper info
 */
async function handleLibraryPaperClick(paper) {
    // Close library modal
    closeBrowseLibrary();

    // Search for the paper to get full details
    try {
        showToast(`æ­£åœ¨åŠ è½½ ${paper.arxiv_id} çš„è¯¦ç»†ä¿¡æ¯...`, 'info');
        const searchResult = await SearchGitHubTranslation(paper.arxiv_id);

        if (searchResult && searchResult.found) {
            // Show download dialog
            showArxivSearchResultDialog(paper.arxiv_id, searchResult);
        } else {
            showToast(`æœªæ‰¾åˆ° ${paper.arxiv_id} çš„ç¿»è¯‘`, 'warning');
        }
    } catch (error) {
        console.error('Failed to load paper details:', error);
        showToast('åŠ è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}


// Export functions for testing
export {
    handleProcess,
    handleCancel,
    handleBrowse,
    updateStatus,
    loadPDF,
    setProcessingState,
    openSettings,
    closeSettings,
    saveSettings,
    testConnection,
    performStartupCheck,
    showStartupCheckModal,
    closeStartupCheckModal,
    // PDF Translation exports
    switchMode,
    handleSelectPdf,
    handleTranslatePdf,
    clearSelectedPdf,
    handleCancelPdfTranslation,
    setPdfTranslatingState,
    // Sync scrolling and download exports
    setupPdfSyncScrolling,
    handleDownloadTranslatedPdf,
    showDownloadTranslatedButton,
    hideDownloadTranslatedButton
};
