/**
 * LaTeX ç¿»è¯‘å™¨å‰ç«¯äº¤äº’é€»è¾‘
 * 
 * å®ç°åŠŸèƒ½ï¼š
 * - è¾“å…¥è¡¨å•å¤„ç†ï¼ˆURL/ID/æ–‡ä»¶é€‰æ‹©ï¼‰
 * - ä¸åç«¯çš„ Wails ç»‘å®šè°ƒç”¨
 * - çŠ¶æ€æ˜¾ç¤ºæ›´æ–°
 * - PDF åŠ è½½æ˜¾ç¤º
 * 
 * Validates: Requirements 4.5
 */

import './style.css';
import './app.css';

// Wails runtime for file dialogs and events
import { EventsOn } from '../wailsjs/runtime/runtime.js';

// Error Management module
import { initErrorManagement } from './errors.js';

// Mode Selector module - for work mode detection
import { 
    GetWorkMode, 
    checkStartupMode, 
    updateAboutLicenseInfo, 
    adjustSettingsForMode,
    initModeBindings,
    GetLicenseInfo,
    RefreshLicense
} from './modeSelector.js';

// Backend bindings - these will be generated by Wails
// We need to handle the case where they might not exist yet
let ProcessSource, ProcessSourceWithForce, CheckExistingTranslation, GetStatus, CancelProcess, GetSettings, SaveSettings, TestAPIConnection, OpenFileDialog, OpenDirectoryDialog, GetLastInput, SaveLastInput, GetInputHistory, AddInputHistory, RemoveInputHistory, ClearInputHistory, GetPDFDataURL, DownloadChinesePDF, DownloadBilingualPDF, DownloadLatexZip, OpenURLInBrowser, CheckStartupRequirements, GetLaTeXDownloadURL;

// PDF Translation bindings
let OpenPDFFileDialog, LoadPDF, TranslatePDF, GetPDFStatus, CancelPDFTranslation, GetTranslatedPDFPath, SaveTranslatedPDF;

// Results Management bindings
let ListTranslatedPapers, DeleteTranslatedPaper, RetranslateFromArxiv, OpenPaperResult, ContinueTranslation;

// GitHub Share bindings
let CheckShareStatus, ShareToGitHub, TestGitHubConnection, CheckShareStatusForPaper, SharePaperToGitHub, CheckShareStatusWithCategory;

// GitHub Search bindings
let SearchGitHubTranslation, DownloadGitHubTranslation, DownloadAndOpenGitHubTranslation, ListRecentGitHubTranslations, ListGitHubTranslationsByCategories, GetArxivPaperMetadata, UpdateGitHubToken;

// Error Management bindings
let ListErrors, RetryFromError, ClearError, ClearAllErrors, ExportErrorsToFile, ExportErrorIDsToFile, ReportErrorsToGitHub;

// Paper Categories binding
let GetPaperCategories;

// Paper categories cache
let paperCategories = [];

// Try to import the backend bindings
async function initBindings() {
    try {
        // Dynamic import to handle case where bindings don't exist yet
        const App = await import('../wailsjs/go/main/App.js');
        ProcessSource = App.ProcessSource;
        ProcessSourceWithForce = App.ProcessSourceWithForce;
        CheckExistingTranslation = App.CheckExistingTranslation;
        GetStatus = App.GetStatus;
        CancelProcess = App.CancelProcess;
        GetSettings = App.GetSettings;
        SaveSettings = App.SaveSettings;
        TestAPIConnection = App.TestAPIConnection;
        OpenFileDialog = App.OpenFileDialog;
        OpenDirectoryDialog = App.OpenDirectoryDialog;
        GetLastInput = App.GetLastInput;
        SaveLastInput = App.SaveLastInput;
        GetInputHistory = App.GetInputHistory;
        AddInputHistory = App.AddInputHistory;
        RemoveInputHistory = App.RemoveInputHistory;
        ClearInputHistory = App.ClearInputHistory;
        GetPDFDataURL = App.GetPDFDataURL;
        DownloadChinesePDF = App.DownloadChinesePDF;
        DownloadBilingualPDF = App.DownloadBilingualPDF;
        DownloadLatexZip = App.DownloadLatexZip;
        OpenURLInBrowser = App.OpenURLInBrowser;
        CheckStartupRequirements = App.CheckStartupRequirements;
        GetLaTeXDownloadURL = App.GetLaTeXDownloadURL;
        // PDF Translation bindings
        OpenPDFFileDialog = App.OpenPDFFileDialog;
        LoadPDF = App.LoadPDF;
        TranslatePDF = App.TranslatePDF;
        GetPDFStatus = App.GetPDFStatus;
        CancelPDFTranslation = App.CancelPDFTranslation;
        GetTranslatedPDFPath = App.GetTranslatedPDFPath;
        SaveTranslatedPDF = App.SaveTranslatedPDF;
        // Results Management bindings
        ListTranslatedPapers = App.ListTranslatedPapers;
        DeleteTranslatedPaper = App.DeleteTranslatedPaper;
        RetranslateFromArxiv = App.RetranslateFromArxiv;
        OpenPaperResult = App.OpenPaperResult;
        ContinueTranslation = App.ContinueTranslation;
        // GitHub Share bindings
        CheckShareStatus = App.CheckShareStatus;
        ShareToGitHub = App.ShareToGitHub;
        TestGitHubConnection = App.TestGitHubConnection;
        CheckShareStatusForPaper = App.CheckShareStatusForPaper;
        SharePaperToGitHub = App.SharePaperToGitHub;
        CheckShareStatusWithCategory = App.CheckShareStatusWithCategory;
        // GitHub Search bindings
        SearchGitHubTranslation = App.SearchGitHubTranslation;
        DownloadGitHubTranslation = App.DownloadGitHubTranslation;
        DownloadAndOpenGitHubTranslation = App.DownloadAndOpenGitHubTranslation;
        ListRecentGitHubTranslations = App.ListRecentGitHubTranslations;
        ListGitHubTranslationsByCategories = App.ListGitHubTranslationsByCategories;
        GetArxivPaperMetadata = App.GetArxivPaperMetadata;
        UpdateGitHubToken = App.UpdateGitHubToken;
        // Error Management bindings
        ListErrors = App.ListErrors;
        RetryFromError = App.RetryFromError;
        ClearError = App.ClearError;
        ClearAllErrors = App.ClearAllErrors;
        ExportErrorsToFile = App.ExportErrorsToFile;
        ExportErrorIDsToFile = App.ExportErrorIDsToFile;
        ReportErrorsToGitHub = App.ReportErrorsToGitHub;
        // Paper Categories binding
        GetPaperCategories = App.GetPaperCategories;
        return true;
    } catch (error) {
        console.warn('Backend bindings not available yet:', error);
        // Create mock functions for development
        ProcessSource = async (input) => {
            console.log('Mock ProcessSource called with:', input);
            return { original_pdf_path: '', translated_pdf_path: '' };
        };
        GetStatus = async () => {
            return { phase: 'idle', progress: 0, message: '', error: '' };
        };
        CancelProcess = async () => {
            console.log('Mock CancelProcess called');
        };
        GetSettings = async () => {
            return {
                openai_api_key: '',
                openai_base_url: 'https://api.openai.com/v1',
                openai_model: 'gpt-4',
                context_window: 8192,
                default_compiler: 'pdflatex',
                work_directory: ''
            };
        };
        SaveSettings = async (apiKey, baseUrl, model, contextWindow, compiler, workDir) => {
            console.log('Mock SaveSettings called');
        };
        TestAPIConnection = async (apiKey, baseUrl, model) => {
            console.log('Mock TestAPIConnection called');
            return null;
        };
        OpenFileDialog = async () => {
            console.log('Mock OpenFileDialog called');
            return '';
        };
        OpenDirectoryDialog = async () => {
            console.log('Mock OpenDirectoryDialog called');
            return '';
        };
        GetLastInput = async () => {
            console.log('Mock GetLastInput called');
            return '';
        };
        SaveLastInput = async (input) => {
            console.log('Mock SaveLastInput called with:', input);
        };
        GetInputHistory = async () => {
            console.log('Mock GetInputHistory called');
            return [];
        };
        AddInputHistory = async (input, inputType) => {
            console.log('Mock AddInputHistory called with:', input, inputType);
        };
        RemoveInputHistory = async (input) => {
            console.log('Mock RemoveInputHistory called with:', input);
        };
        ClearInputHistory = async () => {
            console.log('Mock ClearInputHistory called');
        };
        GetPDFDataURL = async (path) => {
            console.log('Mock GetPDFDataURL called with:', path);
            return '';
        };
        CheckStartupRequirements = async () => {
            console.log('Mock CheckStartupRequirements called');
            return { latex_installed: true, latex_version: 'Mock', llm_configured: true, llm_error: '' };
        };
        GetLaTeXDownloadURL = async () => {
            console.log('Mock GetLaTeXDownloadURL called');
            return 'https://miktex.org/download';
        };
        // Mock PDF Translation functions
        OpenPDFFileDialog = async () => {
            console.log('Mock OpenPDFFileDialog called');
            return '';
        };
        LoadPDF = async (filePath) => {
            console.log('Mock LoadPDF called with:', filePath);
            return { file_path: filePath, file_name: 'test.pdf', page_count: 10, file_size: 1024000, is_text_pdf: true };
        };
        TranslatePDF = async () => {
            console.log('Mock TranslatePDF called');
            return { original_pdf_path: '', translated_pdf_path: '', total_blocks: 0, translated_blocks: 0 };
        };
        GetPDFStatus = async () => {
            return { phase: 'idle', progress: 0, message: '', total_blocks: 0, completed_blocks: 0, error: '' };
        };
        CancelPDFTranslation = async () => {
            console.log('Mock CancelPDFTranslation called');
        };
        GetTranslatedPDFPath = async () => {
            console.log('Mock GetTranslatedPDFPath called');
            return '';
        };
        // Mock GitHub Search functions
        SearchGitHubTranslation = async (arxivId) => {
            console.log('Mock SearchGitHubTranslation called with:', arxivId);
            return { found: false };
        };
        DownloadGitHubTranslation = async (arxivId, fileType, saveDir) => {
            console.log('Mock DownloadGitHubTranslation called');
            return '';
        };
        ListRecentGitHubTranslations = async (maxCount) => {
            console.log('Mock ListRecentGitHubTranslations called with:', maxCount);
            return [];
        };
        ListGitHubTranslationsByCategories = async (categories, maxCount) => {
            console.log('Mock ListGitHubTranslationsByCategories called with:', categories, maxCount);
            return [];
        };
        GetArxivPaperMetadata = async (arxivId) => {
            console.log('Mock GetArxivPaperMetadata called with:', arxivId);
            return { arxiv_id: arxivId, title: 'Mock Title', abstract: 'Mock abstract', authors: 'Mock Authors' };
        };
        UpdateGitHubToken = async () => {
            console.log('Mock UpdateGitHubToken called');
            return null;
        };
        // Mock Error Management functions
        ListErrors = async () => {
            console.log('Mock ListErrors called');
            return [];
        };
        RetryFromError = async (id) => {
            console.log('Mock RetryFromError called with:', id);
            return { original_pdf_path: '', translated_pdf_path: '' };
        };
        ClearError = async (id) => {
            console.log('Mock ClearError called with:', id);
        };
        ClearAllErrors = async () => {
            console.log('Mock ClearAllErrors called');
        };
        ExportErrorsToFile = async () => {
            console.log('Mock ExportErrorsToFile called');
            return '/path/to/exported/file.txt';
        };
        ExportErrorIDsToFile = async () => {
            console.log('Mock ExportErrorIDsToFile called');
            return '/path/to/exported/ids.txt';
        };
        ReportErrorsToGitHub = async () => {
            console.log('Mock ReportErrorsToGitHub called');
            return { success: true, issue_url: 'https://github.com/example/repo/issues/1', issue_number: 1 };
        };
        // Mock Paper Categories function
        GetPaperCategories = async () => {
            console.log('Mock GetPaperCategories called');
            return [
                { id: 'llm', name: 'å¤§è¯­è¨€æ¨¡å‹', description: 'GPTã€LLaMAã€Claudeç­‰' },
                { id: 'cv', name: 'è®¡ç®—æœºè§†è§‰', description: 'å›¾åƒè¯†åˆ«ã€ç›®æ ‡æ£€æµ‹ç­‰' },
                { id: 'other', name: 'å…¶ä»–', description: 'å…¶ä»–AIç›¸å…³è®ºæ–‡' }
            ];
        };
        return false;
    }
}

// DOM Elements
let inputSource;
let btnBrowse;
let btnProcess;
let btnCancel;
let btnSettings;
let pdfLeftIframe;
let pdfRightIframe;
let pdfLeftPlaceholder;
let pdfRightPlaceholder;
let statusDot;
let statusMessage;
let statusPhase;
let progressContainer;
let progressFill;
let progressText;

// Download dropdown elements
let downloadDropdown;
let btnDownload;
let downloadMenu;

// Settings modal elements
let settingsModal;
let settingApiKey;
let settingBaseUrl;
let settingModel;
let settingContextWindow;
let settingCompiler;
let settingWorkdir;
let settingConcurrency;
let settingLibraryPageSize;
let btnBrowseWorkdir;
let btnSettingsCancel;
let btnSettingsSave;
let btnTestConnection;
let testStatus;
let modalClose;

// About modal elements
let aboutModal;
let btnAbout;
let aboutModalClose;
let btnAboutClose;

// Results management modal elements
let resultsModal;
let btnResults;
let resultsModalClose;
let btnResultsClose;
let resultsList;
let resultsEmpty;

// Share modal elements
let shareModal;
let btnShare;
let shareModalClose;
let btnShareCancel;
let btnShareConfirm;
let shareChineseCheck;
let shareBilingualCheck;
let shareChineseName;
let shareBilingualName;
let shareChineseStatus;
let shareBilingualStatus;
let shareWarning;
let shareProgress;
let shareCategory;
let shareCategoryHint;

// GitHub settings elements
let settingGitHubToken;
let btnUpdateGitHubToken;
let btnTestGitHub;
let githubTestStatus;
let githubUpdateStatus;

// Settings - share prompt
let settingSharePrompt;

// Default GitHub repository settings
const DEFAULT_GITHUB_OWNER = 'rapidaicoder';
const DEFAULT_GITHUB_REPO = 'chinesepaper';

// arXiv Search elements
let arxivSearchInput;
let btnArxivSearch;
let btnBrowseLibrary;

// Browse Library Modal elements
let browseLibraryModal;
let libraryModalClose;
let btnLibraryClose;
let libraryLoading;
let libraryContent;
let libraryList;
let libraryEmpty;
let libraryPagination;
let btnFirstPage;
let btnPrevPage;
let btnNextPage;
let btnLastPage;
let currentPageSpan;
let libraryFilter;
let categoryFilterTags;
let totalPagesSpan;
let totalPapersSpan;

// GitHub Download Modal elements
let githubDownloadModal;
let downloadModalClose;
let downloadArxivId;
let downloadChineseItem;
let downloadChineseCheck;
let downloadChineseName;
let downloadBilingualItem;
let downloadBilingualCheck;
let downloadBilingualName;
let downloadLatexItem;
let downloadLatexCheck;
let downloadLatexName;
let downloadProgress;
let downloadProgressText;
let btnDownloadCancel;
let btnDownloadConfirm;

// Share Prompt Modal elements
let sharePromptModal;
let sharePromptModalClose;
let btnSharePromptCancel;
let btnSharePromptConfirm;

// Translate Confirm Modal elements
let translateConfirmModal;
let translateConfirmModalClose;
let translateConfirmIntro;
let previewArxivId;
let previewTitle;
let previewAuthors;
let btnTranslateCancel;
let btnTranslateConfirm;
let pendingTranslateArxivId = null;

// Generic Confirm Modal elements (for custom confirm dialogs)
let genericConfirmModal;
let genericConfirmTitle;
let genericConfirmMessage;
let genericConfirmModalClose;
let btnGenericCancel;
let btnGenericConfirm;
let genericConfirmResolve = null;

// Current download state
let currentDownloadData = null;

// Library browser state
let allPapers = []; // All papers from GitHub
let currentPage = 1;

// History elements
let btnHistory;
let historyDropdown;
let historyList;
let historyEmpty;
let btnClearHistory;
let pageSize = 20; // Default page size, will be loaded from config
let totalPages = 1;

// Paper metadata cache - stores title by arXiv ID (no abstract to avoid tooltip interference)
// This cache is persisted to localStorage for faster loading
const paperMetadataCache = new Map();

// Load cached metadata from localStorage on startup
function loadMetadataCache() {
    try {
        const cached = localStorage.getItem('paperMetadataCache');
        if (cached) {
            const data = JSON.parse(cached);
            for (const [key, value] of Object.entries(data)) {
                paperMetadataCache.set(key, value);
            }
            console.log(`Loaded ${paperMetadataCache.size} cached paper titles`);
        }
    } catch (error) {
        console.warn('Failed to load metadata cache:', error);
    }
}

// Save metadata cache to localStorage
function saveMetadataCache() {
    try {
        const data = Object.fromEntries(paperMetadataCache);
        localStorage.setItem('paperMetadataCache', JSON.stringify(data));
    } catch (error) {
        console.warn('Failed to save metadata cache:', error);
    }
}

// Startup check modal elements
let startupCheckModal;
let latexSpinner;
let latexStatus;
let latexDetail;
let latexAction;
let latexDownloadLink;
let llmSpinner;
let llmStatus;
let llmDetail;
let llmAction;
let btnConfigureLlm;
let btnRecheck;
let btnContinue;
let checkLatexItem;
let checkLlmItem;

// PDF Translation mode elements
let modeTabLatex;
let modeTabPdf;
let latexInputSection;
let pdfInputSection;
let pdfDropZone;
let btnSelectPdf;
let pdfFileSelected;
let pdfFileName;
let pdfFileSize;
let btnClearPdf;
let btnTranslatePdf;
let btnDownloadTranslated;

// PDF sync scrolling state
let isSyncScrolling = false;
let translatedPdfPath = null;

// Track if API test passed
let apiTestPassed = false;

// Track original LLM settings to detect changes
let originalLlmSettings = {
    apiKey: '',
    baseUrl: '',
    model: ''
};

// Track if this is first-time open source mode setup
// Validates: Requirements 4.1, 4.2, 4.7
let isFirstTimeSetup = false;

// Application state
let isProcessing = false;
let statusPollInterval = null;
let currentResult = null; // Store the current processing result

// PDF Translation state
let currentMode = 'latex'; // 'latex' or 'pdf'
let isPdfTranslating = false;
let pdfStatusPollInterval = null;
let currentPdfInfo = null; // Store loaded PDF info
let currentPdfFilePath = null; // Store selected PDF file path
let currentPdfTranslatedPath = null; // Store translated PDF path for PDF mode

// æ¨¡å¼åˆ‡æ¢æ—¶ä¿å­˜çš„ PDF è·¯å¾„
let latexModeLeftPdf = null;  // LaTeX æ¨¡å¼å·¦ä¾§ PDF è·¯å¾„
let latexModeRightPdf = null; // LaTeX æ¨¡å¼å³ä¾§ PDF è·¯å¾„
let pdfModeLeftPdf = null;    // PDF æ¨¡å¼å·¦ä¾§ PDF è·¯å¾„
let pdfModeRightPdf = null;   // PDF æ¨¡å¼å³ä¾§ PDF è·¯å¾„

// æ¨¡å¼åˆ‡æ¢æ—¶ä¿å­˜çš„çŠ¶æ€æ çŠ¶æ€
let latexModeStatus = { phase: 'idle', progress: 0, message: 'å°±ç»ª', error: null };
let pdfModeStatus = { phase: 'idle', progress: 0, message: 'å°±ç»ª', error: null };

// Library browser state
let selectedCategories = ['all']; // Selected category filters for library browser

// Toast container element
let toastContainer;

/**
 * Show a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Type: 'success', 'error', 'warning', 'info'
 * @param {number} duration - Duration in ms (default 3000)
 */
function showToast(message, type = 'info', duration = 3000) {
    if (!toastContainer) {
        toastContainer = document.getElementById('toast-container');
    }

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Auto remove after duration
    setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => {
            toast.remove();
        }, 300);
    }, duration);
}

/**
 * Show a custom confirm dialog
 * @param {string} message - Confirm message
 * @param {string} title - Dialog title (optional)
 * @param {string} confirmText - Confirm button text (optional)
 * @param {string} cancelText - Cancel button text (optional)
 * @returns {Promise<boolean>} - User choice result
 */
function showConfirmDialog(message, title = 'ç¡®è®¤', confirmText = 'ç¡®å®š', cancelText = 'å–æ¶ˆ') {
    return new Promise((resolve) => {
        if (!genericConfirmModal) {
            // Fallback to native confirm if modal not available
            resolve(confirm(message));
            return;
        }

        genericConfirmResolve = resolve;
        
        if (genericConfirmTitle) genericConfirmTitle.textContent = title;
        if (genericConfirmMessage) genericConfirmMessage.textContent = message;
        if (btnGenericConfirm) btnGenericConfirm.textContent = confirmText;
        if (btnGenericCancel) btnGenericCancel.textContent = cancelText;
        
        genericConfirmModal.classList.add('visible');
    });
}

/**
 * Close generic confirm dialog
 * @param {boolean} result - User choice result
 */
function closeGenericConfirm(result) {
    if (genericConfirmModal) {
        genericConfirmModal.classList.remove('visible');
    }
    if (genericConfirmResolve) {
        genericConfirmResolve(result);
        genericConfirmResolve = null;
    }
}

/**
 * Phase display names mapping
 */
const phaseDisplayNames = {
    'idle': 'ç©ºé—²',
    'downloading': 'ä¸‹è½½ä¸­',
    'extracting': 'è§£å‹ä¸­',
    'compiling': 'ç¼–è¯‘ä¸­',
    'translating': 'ç¿»è¯‘ä¸­',
    'validating': 'éªŒè¯ä¸­',
    'complete': 'å®Œæˆ',
    'error': 'é”™è¯¯',
    // PDF Translation phases
    'loading': 'åŠ è½½ä¸­',
    'generating': 'ç”Ÿæˆä¸­'
};

/**
 * Initialize DOM element references
 */
function initElements() {
    inputSource = document.getElementById('input-source');
    btnBrowse = document.getElementById('btn-browse');
    btnProcess = document.getElementById('btn-process');
    btnCancel = document.getElementById('btn-cancel');
    btnSettings = document.getElementById('btn-settings');
    pdfLeftIframe = document.getElementById('pdf-left-iframe');
    pdfRightIframe = document.getElementById('pdf-right-iframe');
    pdfLeftPlaceholder = document.getElementById('pdf-left-placeholder');
    pdfRightPlaceholder = document.getElementById('pdf-right-placeholder');
    statusDot = document.getElementById('status-dot');
    statusMessage = document.getElementById('status-message');
    statusPhase = document.getElementById('status-phase');
    progressContainer = document.getElementById('progress-container');
    progressFill = document.getElementById('progress-fill');
    progressText = document.getElementById('progress-text');

    // Download dropdown elements
    downloadDropdown = document.getElementById('download-dropdown');
    btnDownload = document.getElementById('btn-download');
    downloadMenu = document.getElementById('download-menu');

    // Settings modal elements
    settingsModal = document.getElementById('settings-modal');
    settingApiKey = document.getElementById('setting-api-key');
    settingBaseUrl = document.getElementById('setting-base-url');
    settingModel = document.getElementById('setting-model');
    settingContextWindow = document.getElementById('setting-context-window');
    settingCompiler = document.getElementById('setting-compiler');
    settingWorkdir = document.getElementById('setting-workdir');
    settingConcurrency = document.getElementById('setting-concurrency');
    settingLibraryPageSize = document.getElementById('setting-library-page-size');
    btnBrowseWorkdir = document.getElementById('btn-browse-workdir');
    btnSettingsCancel = document.getElementById('btn-settings-cancel');
    btnSettingsSave = document.getElementById('btn-settings-save');
    btnTestConnection = document.getElementById('btn-test-connection');
    testStatus = document.getElementById('test-status');
    modalClose = document.getElementById('modal-close');

    // About modal elements
    aboutModal = document.getElementById('about-modal');
    btnAbout = document.getElementById('btn-about');
    aboutModalClose = document.getElementById('about-modal-close');
    btnAboutClose = document.getElementById('btn-about-close');

    // Results management modal elements
    resultsModal = document.getElementById('results-modal');
    btnResults = document.getElementById('btn-results');
    resultsModalClose = document.getElementById('results-modal-close');
    btnResultsClose = document.getElementById('btn-results-close');
    resultsList = document.getElementById('results-list');
    resultsEmpty = document.getElementById('results-empty');

    // Share modal elements
    shareModal = document.getElementById('share-modal');
    btnShare = document.getElementById('btn-share');
    shareModalClose = document.getElementById('share-modal-close');
    btnShareCancel = document.getElementById('btn-share-cancel');
    btnShareConfirm = document.getElementById('btn-share-confirm');
    shareChineseCheck = document.getElementById('share-chinese-check');
    shareBilingualCheck = document.getElementById('share-bilingual-check');
    shareChineseName = document.getElementById('share-chinese-name');
    shareBilingualName = document.getElementById('share-bilingual-name');
    shareChineseStatus = document.getElementById('share-chinese-status');
    shareBilingualStatus = document.getElementById('share-bilingual-status');
    shareWarning = document.getElementById('share-warning');
    shareProgress = document.getElementById('share-progress');
    shareCategory = document.getElementById('share-category');
    shareCategoryHint = document.getElementById('share-category-hint');

    // GitHub settings elements
    settingGitHubToken = document.getElementById('setting-github-token');
    btnUpdateGitHubToken = document.getElementById('btn-update-github-token');
    btnTestGitHub = document.getElementById('btn-test-github');
    githubTestStatus = document.getElementById('github-test-status');
    githubUpdateStatus = document.getElementById('github-update-status');

    // Settings - share prompt
    settingSharePrompt = document.getElementById('setting-share-prompt');

    // Startup check modal elements
    startupCheckModal = document.getElementById('startup-check-modal');
    latexSpinner = document.getElementById('latex-spinner');
    latexStatus = document.getElementById('latex-status');
    latexDetail = document.getElementById('latex-detail');
    latexAction = document.getElementById('latex-action');
    latexDownloadLink = document.getElementById('latex-download-link');
    llmSpinner = document.getElementById('llm-spinner');
    llmStatus = document.getElementById('llm-status');
    llmDetail = document.getElementById('llm-detail');
    llmAction = document.getElementById('llm-action');
    btnConfigureLlm = document.getElementById('btn-configure-llm');
    btnRecheck = document.getElementById('btn-recheck');
    btnContinue = document.getElementById('btn-continue');
    checkLatexItem = document.getElementById('check-latex');
    checkLlmItem = document.getElementById('check-llm');

    // PDF Translation mode elements
    modeTabLatex = document.getElementById('mode-tab-latex');
    modeTabPdf = document.getElementById('mode-tab-pdf');
    latexInputSection = document.getElementById('latex-input-section');
    pdfInputSection = document.getElementById('pdf-input-section');
    pdfDropZone = document.getElementById('pdf-drop-zone');
    btnSelectPdf = document.getElementById('btn-select-pdf');
    pdfFileSelected = document.getElementById('pdf-file-selected');
    pdfFileName = document.getElementById('pdf-file-name');
    pdfFileSize = document.getElementById('pdf-file-size');
    btnClearPdf = document.getElementById('btn-clear-pdf');
    btnTranslatePdf = document.getElementById('btn-translate-pdf');
    btnDownloadTranslated = document.getElementById('btn-download-translated');

    // arXiv Search elements
    arxivSearchInput = document.getElementById('arxiv-search-input');
    btnArxivSearch = document.getElementById('btn-arxiv-search');
    btnBrowseLibrary = document.getElementById('btn-browse-library');

    // Browse Library Modal elements
    browseLibraryModal = document.getElementById('browse-library-modal');
    libraryModalClose = document.getElementById('library-modal-close');
    btnLibraryClose = document.getElementById('btn-library-close');
    libraryLoading = document.getElementById('library-loading');
    libraryContent = document.getElementById('library-content');
    libraryList = document.getElementById('library-list');
    libraryEmpty = document.getElementById('library-empty');
    libraryPagination = document.getElementById('library-pagination');
    btnFirstPage = document.getElementById('btn-first-page');

    // History elements
    btnHistory = document.getElementById('btn-history');
    historyDropdown = document.getElementById('history-dropdown');
    historyList = document.getElementById('history-list');
    historyEmpty = document.getElementById('history-empty');
    btnClearHistory = document.getElementById('btn-clear-history');
    btnPrevPage = document.getElementById('btn-prev-page');
    btnNextPage = document.getElementById('btn-next-page');
    btnLastPage = document.getElementById('btn-last-page');
    currentPageSpan = document.getElementById('current-page');
    totalPagesSpan = document.getElementById('total-pages');
    totalPapersSpan = document.getElementById('total-papers');
    libraryFilter = document.getElementById('library-filter');
    categoryFilterTags = document.getElementById('category-filter-tags');

    // GitHub Download Modal elements
    githubDownloadModal = document.getElementById('github-download-modal');
    downloadModalClose = document.getElementById('download-modal-close');
    downloadArxivId = document.getElementById('download-arxiv-id');
    downloadChineseItem = document.getElementById('download-chinese-item');
    downloadChineseCheck = document.getElementById('download-chinese-check');
    downloadChineseName = document.getElementById('download-chinese-name');
    downloadBilingualItem = document.getElementById('download-bilingual-item');
    downloadBilingualCheck = document.getElementById('download-bilingual-check');
    downloadBilingualName = document.getElementById('download-bilingual-name');
    downloadLatexItem = document.getElementById('download-latex-item');
    downloadLatexCheck = document.getElementById('download-latex-check');
    downloadLatexName = document.getElementById('download-latex-name');
    downloadProgress = document.getElementById('download-progress');
    downloadProgressText = document.getElementById('download-progress-text');
    btnDownloadCancel = document.getElementById('btn-download-cancel');
    btnDownloadConfirm = document.getElementById('btn-download-confirm');

    // Share Prompt Modal elements
    sharePromptModal = document.getElementById('share-prompt-modal');
    sharePromptModalClose = document.getElementById('share-prompt-modal-close');
    btnSharePromptCancel = document.getElementById('btn-share-prompt-cancel');
    btnSharePromptConfirm = document.getElementById('btn-share-prompt-confirm');

    // Translate Confirm Modal elements
    translateConfirmModal = document.getElementById('translate-confirm-modal');
    translateConfirmModalClose = document.getElementById('translate-confirm-modal-close');
    translateConfirmIntro = document.getElementById('translate-confirm-intro');
    previewArxivId = document.getElementById('preview-arxiv-id');
    previewTitle = document.getElementById('preview-title');
    previewAuthors = document.getElementById('preview-authors');
    btnTranslateCancel = document.getElementById('btn-translate-cancel');
    btnTranslateConfirm = document.getElementById('btn-translate-confirm');

    // Generic Confirm Modal elements
    genericConfirmModal = document.getElementById('generic-confirm-modal');
    genericConfirmTitle = document.getElementById('generic-confirm-title');
    genericConfirmMessage = document.getElementById('generic-confirm-message');
    genericConfirmModalClose = document.getElementById('generic-confirm-modal-close');
    btnGenericCancel = document.getElementById('btn-generic-cancel');
    btnGenericConfirm = document.getElementById('btn-generic-confirm');
}

/**
 * Set up event listeners for UI interactions
 */
function setupEventListeners() {
    // Process button click
    btnProcess.addEventListener('click', handleProcess);

    // Cancel button click
    btnCancel.addEventListener('click', handleCancel);

    // Browse button click
    btnBrowse.addEventListener('click', handleBrowse);

    // Settings button click
    btnSettings.addEventListener('click', openSettings);

    // Download dropdown events
    btnDownload.addEventListener('click', toggleDownloadMenu);
    document.getElementById('download-chinese-pdf').addEventListener('click', () => downloadFile('chinese'));
    document.getElementById('download-bilingual-pdf').addEventListener('click', () => downloadFile('bilingual'));
    document.getElementById('download-latex-zip').addEventListener('click', () => downloadFile('latex'));

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!downloadDropdown.contains(e.target)) {
            downloadMenu.classList.remove('show');
        }
    });

    // Settings modal events
    modalClose.addEventListener('click', closeSettings);
    btnSettingsCancel.addEventListener('click', closeSettings);
    btnSettingsSave.addEventListener('click', saveSettings);
    btnTestConnection.addEventListener('click', testConnection);
    btnBrowseWorkdir.addEventListener('click', browseWorkdir);

    // Settings tabs events
    document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const tabId = tab.dataset.tab;
            // Update tab buttons
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            // Update tab content
            document.querySelectorAll('.settings-tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`settings-tab-${tabId}`).classList.add('active');
        });
    });

    // License refresh button event
    const btnRefreshLicense = document.getElementById('btn-refresh-license');
    if (btnRefreshLicense) {
        btnRefreshLicense.addEventListener('click', refreshLicense);
    }

    // Reset test status when settings change
    settingApiKey.addEventListener('input', resetTestStatus);
    settingBaseUrl.addEventListener('input', resetTestStatus);
    settingModel.addEventListener('input', resetTestStatus);

    // Close modal when clicking overlay (but not modal content)
    settingsModal.addEventListener('mousedown', (e) => {
        // Only close if clicking directly on the overlay, not on any child elements
        if (e.target === settingsModal) {
            closeSettings();
        }
    });

    // Prevent keyboard shortcuts from being intercepted by Wails when in modal
    settingsModal.addEventListener('keydown', (e) => {
        // Allow all keyboard events inside the modal
        e.stopPropagation();
    });

    // About modal events
    btnAbout.addEventListener('click', openAbout);
    aboutModalClose.addEventListener('click', closeAbout);
    btnAboutClose.addEventListener('click', closeAbout);
    aboutModal.addEventListener('mousedown', (e) => {
        if (e.target === aboutModal) {
            closeAbout();
        }
    });

    // GitHub link - open in external browser
    document.getElementById('github-link').addEventListener('click', (e) => {
        e.preventDefault();
        OpenURLInBrowser('https://github.com/RapidAI/RapidTrans');
    });

    // Results management modal events
    btnResults.addEventListener('click', openResults);
    resultsModalClose.addEventListener('click', closeResults);
    btnResultsClose.addEventListener('click', closeResults);
    resultsModal.addEventListener('mousedown', (e) => {
        if (e.target === resultsModal) {
            closeResults();
        }
    });

    // Share modal events
    btnShare.addEventListener('click', openShare);
    shareModalClose.addEventListener('click', closeShare);
    btnShareCancel.addEventListener('click', closeShare);
    btnShareConfirm.addEventListener('click', confirmShare);
    shareModal.addEventListener('mousedown', (e) => {
        if (e.target === shareModal) {
            closeShare();
        }
    });

    // GitHub settings events
    btnUpdateGitHubToken.addEventListener('click', updateGitHubToken);
    btnTestGitHub.addEventListener('click', testGitHubConnection);

    // Startup check modal events
    btnRecheck.addEventListener('click', performStartupCheck);
    btnContinue.addEventListener('click', closeStartupCheckModal);
    btnConfigureLlm.addEventListener('click', () => {
        closeStartupCheckModal();
        openSettings();
    });
    latexDownloadLink.addEventListener('click', async (e) => {
        e.preventDefault();
        const url = await GetLaTeXDownloadURL();
        OpenURLInBrowser(url);
    });

    // Enter key in input field
    inputSource.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isProcessing) {
            handleProcess();
        }
    });

    // Enable context menu (right-click) for input field
    // This ensures copy/paste/cut operations work properly
    inputSource.addEventListener('contextmenu', (e) => {
        e.stopPropagation(); // Allow default browser context menu
    });

    // History button and dropdown events
    if (btnHistory) {
        btnHistory.addEventListener('click', toggleHistoryDropdown);
    }
    if (btnClearHistory) {
        btnClearHistory.addEventListener('click', clearHistory);
    }
    // Close history dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (historyDropdown && !historyDropdown.contains(e.target) && e.target !== btnHistory) {
            historyDropdown.classList.remove('show');
        }
    });

    // Listen for status updates from backend (if using events)
    EventsOn('status-update', handleStatusUpdate);

    // Listen for PDF ready events
    EventsOn('original-pdf-ready', (data) => {
        console.log('Original PDF ready:', data);
        if (typeof data === 'string') {
            // Legacy format: just path
            loadPDF('left', data);
        } else if (data && data.pdfPath) {
            // New format: object with pdfPath and arxivId
            loadPDF('left', data.pdfPath, data.arxivId);
        }
    });

    EventsOn('translated-pdf-ready', (data) => {
        console.log('Translated PDF ready:', data);
        if (typeof data === 'string') {
            // Legacy format: just path
            loadPDF('right', data);
        } else if (data && data.pdfPath) {
            // New format: object with pdfPath and arxivId
            loadPDF('right', data.pdfPath, data.arxivId);
        }
    });

    // PDF Translation mode event listeners
    setupPdfModeEventListeners();

    // arXiv Search event listeners
    btnArxivSearch.addEventListener('click', handleArxivSearch);
    arxivSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleArxivSearch();
        }
    });

    // Enable context menu for arXiv search input
    arxivSearchInput.addEventListener('contextmenu', (e) => {
        e.stopPropagation(); // Allow default browser context menu
    });

    // Browse Library event listeners
    btnBrowseLibrary.addEventListener('click', openBrowseLibrary);
    libraryModalClose.addEventListener('click', closeBrowseLibrary);
    btnLibraryClose.addEventListener('click', closeBrowseLibrary);
    browseLibraryModal.addEventListener('mousedown', (e) => {
        if (e.target === browseLibraryModal) {
            closeBrowseLibrary();
        }
    });
    
    // Pagination event listeners
    btnFirstPage.addEventListener('click', () => goToPage(1));
    btnPrevPage.addEventListener('click', () => goToPage(currentPage - 1));
    btnNextPage.addEventListener('click', () => goToPage(currentPage + 1));
    btnLastPage.addEventListener('click', () => goToPage(totalPages));

    // GitHub Download Modal event listeners
    downloadModalClose.addEventListener('click', closeDownloadModal);
    btnDownloadCancel.addEventListener('click', closeDownloadModal);
    btnDownloadConfirm.addEventListener('click', confirmDownload);
    githubDownloadModal.addEventListener('mousedown', (e) => {
        if (e.target === githubDownloadModal) {
            closeDownloadModal();
        }
    });

    // Share Prompt Modal event listeners
    sharePromptModalClose.addEventListener('click', closeSharePromptModal);
    btnSharePromptCancel.addEventListener('click', closeSharePromptModal);
    btnSharePromptConfirm.addEventListener('click', confirmSharePrompt);
    sharePromptModal.addEventListener('mousedown', (e) => {
        if (e.target === sharePromptModal) {
            closeSharePromptModal();
        }
    });

    // Translate Confirm Modal event listeners
    translateConfirmModalClose.addEventListener('click', closeTranslateConfirmModal);
    btnTranslateCancel.addEventListener('click', closeTranslateConfirmModal);
    btnTranslateConfirm.addEventListener('click', confirmTranslate);
    translateConfirmModal.addEventListener('mousedown', (e) => {
        if (e.target === translateConfirmModal) {
            closeTranslateConfirmModal();
        }
    });

    // Generic Confirm Modal event listeners
    if (genericConfirmModalClose) {
        genericConfirmModalClose.addEventListener('click', () => closeGenericConfirm(false));
    }
    if (btnGenericCancel) {
        btnGenericCancel.addEventListener('click', () => closeGenericConfirm(false));
    }
    if (btnGenericConfirm) {
        btnGenericConfirm.addEventListener('click', () => closeGenericConfirm(true));
    }
    if (genericConfirmModal) {
        genericConfirmModal.addEventListener('mousedown', (e) => {
            if (e.target === genericConfirmModal) {
                closeGenericConfirm(false);
            }
        });
    }

    // Listen for first-time setup event from modeSelector
    // Validates: Requirements 4.1, 4.2, 4.7
    window.addEventListener('open-settings-first-time', () => {
        openSettingsForFirstTimeSetup();
    });
}

/**
 * Toggle download dropdown menu
 */
function toggleDownloadMenu(e) {
    e.stopPropagation();
    downloadMenu.classList.toggle('show');
}

/**
 * Download file based on type
 * @param {string} type - 'chinese', 'bilingual', or 'latex'
 */
async function downloadFile(type) {
    downloadMenu.classList.remove('show');

    if (!currentResult) {
        showToast('æ²¡æœ‰å¯ä¸‹è½½çš„å†…å®¹ï¼Œè¯·å…ˆå¤„ç†æ–‡æ¡£', 'warning');
        return;
    }

    try {
        let savePath;
        switch (type) {
            case 'chinese':
                showToast('æ­£åœ¨å‡†å¤‡ä¸­æ–‡ PDF...', 'info');
                savePath = await DownloadChinesePDF();
                if (savePath) {
                    showToast('ä¸­æ–‡ PDF å·²ä¿å­˜', 'success');
                }
                break;
            case 'bilingual':
                showToast('æ­£åœ¨ç”Ÿæˆä¸­è‹±å¯¹ç…§ PDF...', 'info');
                savePath = await DownloadBilingualPDF();
                if (savePath) {
                    showToast('ä¸­è‹±å¯¹ç…§ PDF å·²ä¿å­˜', 'success');
                }
                break;
            case 'latex':
                showToast('æ­£åœ¨æ‰“åŒ… LaTeX æ–‡ä»¶...', 'info');
                savePath = await DownloadLatexZip();
                if (savePath) {
                    showToast('LaTeX æ–‡ä»¶å·²ä¿å­˜', 'success');
                }
                break;
        }
    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Handle the browse button click to select a local zip file
 */
async function handleBrowse() {
    try {
        const result = await OpenFileDialog();
        if (result) {
            inputSource.value = result;
        }
    } catch (error) {
        console.error('Error opening file dialog:', error);
        showError('æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†å¤±è´¥');
    }
}

// ============================================
// History Management Functions
// ============================================

/**
 * Toggle history dropdown visibility
 */
function toggleHistoryDropdown(e) {
    e.stopPropagation();
    if (historyDropdown) {
        const isVisible = historyDropdown.classList.contains('show');
        if (!isVisible) {
            loadHistory();
        }
        historyDropdown.classList.toggle('show');
    }
}

/**
 * Load and display history
 */
async function loadHistory() {
    try {
        const history = await GetInputHistory();
        
        if (!history || history.length === 0) {
            historyList.innerHTML = '';
            historyEmpty.style.display = 'block';
            return;
        }

        historyEmpty.style.display = 'none';
        historyList.innerHTML = '';

        // Display history items (most recent first)
        history.forEach((item) => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            
            const text = document.createElement('span');
            text.className = 'history-text';
            text.textContent = item.input || item; // Handle both object and string formats
            text.title = item.input || item;
            
            const btnRemove = document.createElement('button');
            btnRemove.className = 'btn-remove-history';
            btnRemove.innerHTML = 'Ã—';
            btnRemove.title = 'åˆ é™¤';
            
            // Click on text to use this history item
            text.addEventListener('click', () => {
                inputSource.value = item.input || item;
                historyDropdown.classList.remove('show');
            });
            
            // Click on remove button to delete this item
            btnRemove.addEventListener('click', async (e) => {
                e.stopPropagation();
                await removeHistoryItem(item.input || item);
            });
            
            historyItem.appendChild(text);
            historyItem.appendChild(btnRemove);
            historyList.appendChild(historyItem);
        });
    } catch (error) {
        console.error('Failed to load history:', error);
    }
}

/**
 * Remove a history item
 */
async function removeHistoryItem(input) {
    try {
        await RemoveInputHistory(input);
        await loadHistory(); // Reload the list
    } catch (error) {
        console.error('Failed to remove history item:', error);
        showToast('åˆ é™¤å†å²è®°å½•å¤±è´¥', 'error');
    }
}

/**
 * Clear all history
 */
async function clearHistory() {
    try {
        await ClearInputHistory();
        await loadHistory(); // Reload the list
        showToast('å†å²è®°å½•å·²æ¸…ç©º', 'success');
    } catch (error) {
        console.error('Failed to clear history:', error);
        showToast('æ¸…ç©ºå†å²è®°å½•å¤±è´¥', 'error');
    }
}

/**
 * Add input to history
 */
async function addToHistory(input) {
    if (!input || input.trim() === '') {
        return;
    }
    
    try {
        // Determine input type
        let inputType = 'unknown';
        if (input.includes('arxiv.org')) {
            inputType = 'url';
        } else if (/^\d{4}\.\d{4,5}(v\d+)?$/.test(input.trim())) {
            inputType = 'arxiv_id';
        } else if (input.endsWith('.zip') || input.includes('\\') || input.includes('/')) {
            inputType = 'file';
        }
        
        await AddInputHistory(input, inputType);
    } catch (error) {
        console.error('Failed to add to history:', error);
    }
}

/**
 * Handle the process button click to start processing
 */
async function handleProcess() {
    // Prevent duplicate processing
    if (isProcessing) {
        console.warn('Processing already in progress, ignoring duplicate call');
        return;
    }

    const input = inputSource.value.trim();

    if (!input) {
        showError('è¯·è¾“å…¥ arXiv URLã€arXiv ID æˆ–æœ¬åœ° zip æ–‡ä»¶è·¯å¾„');
        return;
    }

    // Save the input for next time
    SaveLastInput(input);
    
    // Add to history
    await addToHistory(input);

    try {
        // Check for existing translation first
        const existingInfo = await CheckExistingTranslation(input);

        if (existingInfo && existingInfo.exists) {
            // Show confirmation dialog based on status
            let confirmMsg = existingInfo.message + '\n\n';
            let dialogTitle = 'å‘ç°å·²æœ‰ç¿»è¯‘';
            let confirmText = 'ç¡®å®š';
            let cancelText = 'å–æ¶ˆ';
            
            if (existingInfo.is_complete) {
                // Translation completed successfully
                confirmMsg += 'æ˜¯å¦è¦é‡æ–°ç¿»è¯‘ï¼Ÿï¼ˆè¿™å°†è¦†ç›–ç°æœ‰ç»“æœï¼‰';
                dialogTitle = 'ğŸ“„ å‘ç°å·²å®Œæˆçš„ç¿»è¯‘';
                confirmText = 'é‡æ–°ç¿»è¯‘';
                cancelText = 'æŸ¥çœ‹ç°æœ‰ç»“æœ';
            } else if (existingInfo.can_continue) {
                // Translation was interrupted, can continue
                confirmMsg += 'æ˜¯å¦è¦ç»§ç»­ç¿»è¯‘ï¼Ÿ';
                dialogTitle = 'ğŸ“„ å‘ç°æœªå®Œæˆçš„ç¿»è¯‘';
                confirmText = 'ç»§ç»­ç¿»è¯‘';
                cancelText = 'é‡æ–°å¼€å§‹';
            } else {
                // Translation failed previously
                confirmMsg += 'æ˜¯å¦è¦é‡æ–°å°è¯•ç¿»è¯‘ï¼Ÿ';
                dialogTitle = 'âŒ å‘ç°ç¿»è¯‘å¤±è´¥çš„è®°å½•';
                confirmText = 'é‡æ–°ç¿»è¯‘';
                cancelText = 'æ”¾å¼ƒ';
            }

            const userChoice = await showConfirmDialog(confirmMsg, dialogTitle, confirmText, cancelText);

            if (existingInfo.is_complete && !userChoice) {
                // User wants to view existing result
                if (existingInfo.paper_info && existingInfo.paper_info.arxiv_id) {
                    showToast('æ­£åœ¨åŠ è½½å·²æœ‰ç¿»è¯‘ç»“æœ...', 'info');
                    const result = await OpenPaperResult(existingInfo.paper_info.arxiv_id);
                    if (result) {
                        currentResult = result;
                        downloadDropdown.style.display = 'inline-block';
                        btnShare.style.display = 'inline-block';
                        const arxivId = existingInfo.paper_info.arxiv_id;
                        if (result.original_pdf_path) {
                            loadPDF('left', result.original_pdf_path, arxivId);
                        }
                        if (result.translated_pdf_path) {
                            loadPDF('right', result.translated_pdf_path, arxivId);
                        }
                        showToast('å·²åŠ è½½ç°æœ‰ç¿»è¯‘ç»“æœ', 'success');
                    }
                }
                return;
            }

            // For failed translations (not can_continue), if user chooses "æ”¾å¼ƒ", just return
            if (!existingInfo.is_complete && !existingInfo.can_continue && !userChoice) {
                showToast('å·²å–æ¶ˆç¿»è¯‘', 'info');
                return;
            }

            // User wants to re-translate or continue
            // Update UI to processing state
            setProcessingState(true);
            resetPDFViewers();
            
            if (existingInfo.is_complete) {
                updateStatus('idle', 0, 'å¼€å§‹é‡æ–°ç¿»è¯‘...');
            } else if (existingInfo.can_continue && userChoice) {
                updateStatus('idle', 0, 'ç»§ç»­ç¿»è¯‘...');
            } else {
                updateStatus('idle', 0, 'å¼€å§‹é‡æ–°ç¿»è¯‘...');
            }
            
            startStatusPolling();

            // Call backend with force option - wrap in try-catch to prevent fallthrough
            try {
                const result = await ProcessSourceWithForce(input, userChoice);
                stopStatusPolling();
                handleProcessResult(result);
            } catch (forceError) {
                console.error('ProcessSourceWithForce error:', forceError);
                stopStatusPolling();
                const errorMsg = forceError.message || forceError.toString() || 'å¤„ç†å¤±è´¥';
                updateStatus('error', 0, errorMsg);
                showError(errorMsg);
            } finally {
                setProcessingState(false);
            }
            return;
        }
    } catch (checkError) {
        console.warn('Failed to check existing translation:', checkError);
        // Continue with normal processing if check fails
    }

    // No existing translation, proceed normally
    setProcessingState(true);
    resetPDFViewers();
    updateStatus('idle', 0, 'å¼€å§‹å¤„ç†...');

    try {
        // Start status polling
        startStatusPolling();

        // Call backend ProcessSource
        const result = await ProcessSource(input);

        // Stop status polling
        stopStatusPolling();

        handleProcessResult(result);
    } catch (error) {
        console.error('Processing error:', error);
        stopStatusPolling();

        // Extract error message
        const errorMsg = error.message || error.toString() || 'å¤„ç†å¤±è´¥';
        updateStatus('error', 0, errorMsg);
        showError(errorMsg);
    } finally {
        setProcessingState(false);
    }
}

/**
 * Handle the process result
 */
async function handleProcessResult(result) {
    if (result) {
        // Store the result for download
        currentResult = result;

        // Processing completed successfully
        updateStatus('complete', 100, 'å¤„ç†å®Œæˆ');

        // Show download button
        downloadDropdown.style.display = 'inline-block';

        // Show share button
        btnShare.style.display = 'inline-block';

        // Extract arXiv ID from result if available
        const arxivId = result.source_id || '';

        // Load PDFs into iframes with arXiv ID
        if (result.original_pdf_path) {
            loadPDF('left', result.original_pdf_path, arxivId);
        }
        if (result.translated_pdf_path) {
            loadPDF('right', result.translated_pdf_path, arxivId);
        }

        showToast('å¤„ç†å®Œæˆï¼Œå¯ä»¥ä¸‹è½½ç»“æœ', 'success');
        
        // Check if share prompt is enabled and prompt user to share
        try {
            const settings = await GetSettings();
            if (settings.share_prompt_enabled !== false) {
                // Delay a bit to let user see the result first
                setTimeout(() => {
                    promptShareAfterTranslation();
                }, 1000);
            }
        } catch (error) {
            console.warn('Failed to check share prompt setting:', error);
        }
    }
    setProcessingState(false);
}

/**
 * Prompt user to share after successful translation
 */
async function promptShareAfterTranslation() {
    // Check if we can share (has GitHub token, is arXiv paper, etc.)
    try {
        const status = await CheckShareStatus();
        if (status.can_share) {
            // Show custom share prompt modal
            openSharePromptModal();
        }
    } catch (error) {
        console.warn('Failed to check share status for prompt:', error);
    }
}

/**
 * Open share prompt modal
 */
function openSharePromptModal() {
    sharePromptModal.classList.add('visible');
}

/**
 * Close share prompt modal
 */
function closeSharePromptModal() {
    sharePromptModal.classList.remove('visible');
}

/**
 * Handle share prompt confirmation
 */
function confirmSharePrompt() {
    closeSharePromptModal();
    openShare();
}

/**
 * Handle the cancel button click to cancel processing
 */
async function handleCancel() {
    try {
        await CancelProcess();
        stopStatusPolling();
        updateStatus('idle', 0, 'å¤„ç†å·²å–æ¶ˆ');
        setProcessingState(false);
    } catch (error) {
        console.error('Cancel error:', error);
        showError('å–æ¶ˆå¤„ç†å¤±è´¥');
    }
}

/**
 * Handle status update from backend event
 * @param {Object} status - Status object from backend
 */
function handleStatusUpdate(status) {
    if (status) {
        updateStatus(status.phase, status.progress, status.message, status.error);
    }
}

/**
 * Start polling for status updates (LaTeX mode)
 */
function startStatusPolling() {
    // Poll every 500ms
    statusPollInterval = setInterval(async () => {
        try {
            const status = await GetStatus();
            if (status) {
                // Always save to LaTeX mode status
                latexModeStatus = { 
                    phase: status.phase, 
                    progress: status.progress, 
                    message: status.message || 'å°±ç»ª', 
                    error: status.error || null 
                };
                // Only update display if we're in LaTeX mode
                if (currentMode === 'latex') {
                    applyStatusDisplay(latexModeStatus);
                }
            }
        } catch (error) {
            console.error('Status poll error:', error);
        }
    }, 500);
}

/**
 * Stop polling for status updates
 */
function stopStatusPolling() {
    if (statusPollInterval) {
        clearInterval(statusPollInterval);
        statusPollInterval = null;
    }
}

/**
 * Update the UI to reflect processing state
 * @param {boolean} processing - Whether processing is in progress
 */
function setProcessingState(processing) {
    isProcessing = processing;

    // Update button visibility
    btnProcess.disabled = processing;
    btnProcess.style.display = processing ? 'none' : 'inline-block';
    btnCancel.style.display = processing ? 'inline-block' : 'none';

    // Update input state
    inputSource.disabled = processing;
    btnBrowse.disabled = processing;

    // Update progress container visibility
    if (processing) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }
}

/**
 * Update the status display
 * @param {string} phase - Current processing phase
 * @param {number} progress - Progress percentage (0-100)
 * @param {string} message - Status message
 * @param {string} [error] - Error message if any
 */
function updateStatus(phase, progress, message, error) {
    // ä¿å­˜çŠ¶æ€åˆ°å½“å‰æ¨¡å¼çš„çŠ¶æ€å˜é‡
    const statusState = { phase, progress, message: message || 'å°±ç»ª', error: error || null };
    if (currentMode === 'latex') {
        latexModeStatus = statusState;
    } else {
        pdfModeStatus = statusState;
    }

    // Update status dot
    statusDot.className = 'status-dot';
    if (phase === 'error') {
        statusDot.classList.add('error');
    } else if (phase === 'complete') {
        statusDot.classList.add('success');
    } else if (phase !== 'idle') {
        statusDot.classList.add('processing');
    } else {
        statusDot.classList.add('idle');
    }

    // Update status message
    if (error) {
        statusMessage.textContent = error;
        statusMessage.style.color = '#f44336';
    } else {
        statusMessage.textContent = message || 'å°±ç»ª';
        statusMessage.style.color = '';
    }

    // Update phase display
    statusPhase.textContent = phaseDisplayNames[phase] || phase;

    // Update progress bar
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${progress}%`;
}

/**
 * ç›´æ¥åº”ç”¨çŠ¶æ€æ˜¾ç¤ºï¼ˆä¸ä¿å­˜åˆ°çŠ¶æ€å˜é‡ï¼‰
 * ç”¨äºæ¨¡å¼åˆ‡æ¢æ—¶æ¢å¤çŠ¶æ€
 * @param {Object} status - çŠ¶æ€å¯¹è±¡ { phase, progress, message, error }
 */
function applyStatusDisplay(status) {
    const { phase, progress, message, error } = status;

    // Update status dot
    statusDot.className = 'status-dot';
    if (phase === 'error') {
        statusDot.classList.add('error');
    } else if (phase === 'complete') {
        statusDot.classList.add('success');
    } else if (phase !== 'idle') {
        statusDot.classList.add('processing');
    } else {
        statusDot.classList.add('idle');
    }

    // Update status message
    if (error) {
        statusMessage.textContent = error;
        statusMessage.style.color = '#f44336';
    } else {
        statusMessage.textContent = message || 'å°±ç»ª';
        statusMessage.style.color = '';
    }

    // Update phase display
    statusPhase.textContent = phaseDisplayNames[phase] || phase;

    // Update progress bar
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${progress}%`;
}

/**
 * Reset PDF viewers to placeholder state
 */
function resetPDFViewers() {
    // Hide iframes, show placeholders
    pdfLeftIframe.style.display = 'none';
    pdfRightIframe.style.display = 'none';
    pdfLeftPlaceholder.style.display = 'flex';
    pdfRightPlaceholder.style.display = 'flex';

    // Clear iframe sources - use about:blank to prevent loading main page
    pdfLeftIframe.src = 'about:blank';
    pdfRightIframe.src = 'about:blank';
}

/**
 * Load a PDF into the specified viewer
 * @param {string} side - 'left' or 'right'
 * @param {string} pdfPath - Path to the PDF file (may include query string for cache busting)
 * @param {string} arxivId - Optional arXiv ID to display in URL bar
 */
async function loadPDF(side, pdfPath, arxivId) {
    const iframe = side === 'left' ? pdfLeftIframe : pdfRightIframe;
    const placeholder = side === 'left' ? pdfLeftPlaceholder : pdfRightPlaceholder;

    if (!pdfPath) {
        return;
    }

    console.log('Loading PDF:', side, pdfPath, 'arXiv ID:', arxivId);

    // Separate path and query string if present
    let pathPart = pdfPath;
    let queryPart = '';
    const queryIndex = pdfPath.indexOf('?');
    if (queryIndex !== -1) {
        pathPart = pdfPath.substring(0, queryIndex);
        queryPart = pdfPath.substring(queryIndex);
    }

    // Convert local file path to our custom /pdf/ URL
    // The backend PDFHandler will serve the file
    let pdfUrl = '/pdf/' + pathPart.replace(/\\/g, '/') + queryPart;

    console.log('PDF URL:', pdfUrl);

    // Update URL bar with arXiv ID if provided
    if (arxivId && side === 'left') {
        // Only update URL when loading left (original) PDF to avoid duplicate updates
        try {
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('arxiv', arxivId);
            window.history.pushState({ arxivId: arxivId }, '', newUrl);
            console.log('Updated URL bar with arXiv ID:', arxivId);
        } catch (e) {
            console.warn('Failed to update URL bar:', e);
        }
    }

    // Hide placeholder, show iframe
    placeholder.style.display = 'none';
    iframe.style.display = 'block';
    iframe.src = pdfUrl;
}

/**
 * Show an error message to the user
 * @param {string} message - Error message to display
 * @param {string} [forMode] - Optional: force error to be saved to specific mode ('latex' or 'pdf')
 */
function showError(message, forMode) {
    // ç¡®å®šé”™è¯¯åº”è¯¥ä¿å­˜åˆ°å“ªä¸ªæ¨¡å¼
    const targetMode = forMode || currentMode;
    const errorState = { phase: 'error', progress: 0, message: message, error: message };
    
    if (targetMode === 'latex') {
        latexModeStatus = errorState;
    } else {
        pdfModeStatus = errorState;
    }
    
    // åªæœ‰å½“ç›®æ ‡æ¨¡å¼æ˜¯å½“å‰æ¨¡å¼æ—¶æ‰æ›´æ–°æ˜¾ç¤º
    if (targetMode === currentMode) {
        applyStatusDisplay(errorState);
    }

    // Show toast notification
    showToast(message, 'error', 5000);
    console.error('Error:', message);
}

/**
 * Adjust settings UI based on work mode
 * Hides LLM settings tab in commercial mode, shows it in opensource mode
 * Shows License tab only in commercial mode
 * Validates: Requirements 9.1, 9.2, 9.3
 */
async function adjustSettingsUIForMode() {
    try {
        const workMode = await GetWorkMode();
        
        const llmTabBtn = document.getElementById('settings-tab-btn-llm');
        const llmTabContent = document.getElementById('settings-tab-llm');
        const licenseTabBtn = document.getElementById('settings-tab-btn-license');
        const licenseTabContent = document.getElementById('settings-tab-license');
        
        if (workMode === 'commercial' && !isFirstTimeSetup) {
            // Commercial mode: hide LLM settings tab, show License tab
            if (llmTabBtn) llmTabBtn.style.display = 'none';
            if (llmTabContent) llmTabContent.style.display = 'none';
            if (licenseTabBtn) licenseTabBtn.style.display = '';
            if (licenseTabContent) licenseTabContent.style.display = '';
            
            // Load license info for the license tab
            await loadLicenseSettingsInfo();
            
            // Switch to LaTeX tab if LLM was active
            const latexTab = document.querySelector('[data-tab="latex"]');
            const latexContent = document.getElementById('settings-tab-latex');
            if (latexTab && latexContent) {
                // Remove active from all tabs and contents
                document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
                // Activate LaTeX tab
                latexTab.classList.add('active');
                latexContent.classList.add('active');
            }
        } else {
            // Opensource mode or first-time setup: show LLM settings tab, hide License tab
            if (llmTabBtn) llmTabBtn.style.display = '';
            if (llmTabContent) llmTabContent.style.display = '';
            if (licenseTabBtn) licenseTabBtn.style.display = 'none';
            if (licenseTabContent) licenseTabContent.style.display = 'none';
        }
    } catch (error) {
        console.error('Error adjusting settings for mode:', error);
    }
}

/**
 * Load license info for the settings license tab
 */
async function loadLicenseSettingsInfo() {
    try {
        const licenseInfo = await GetLicenseInfo();
        
        const snEl = document.getElementById('settings-license-sn');
        const expiresEl = document.getElementById('settings-license-expires');
        const dailyEl = document.getElementById('settings-license-daily');
        const remainingEl = document.getElementById('settings-license-remaining');
        const warningEl = document.getElementById('settings-license-warning');
        
        if (snEl) {
            snEl.textContent = licenseInfo.serial_number || '-';
        }
        
        if (expiresEl) {
            expiresEl.textContent = licenseInfo.expires_at || '-';
        }
        
        if (dailyEl) {
            dailyEl.textContent = licenseInfo.daily_analysis > 0 
                ? licenseInfo.daily_analysis + ' æ¬¡/å¤©' 
                : 'æ— é™åˆ¶';
        }
        
        if (remainingEl) {
            if (licenseInfo.days_remaining !== undefined && licenseInfo.days_remaining >= 0) {
                remainingEl.textContent = licenseInfo.days_remaining + ' å¤©';
                if (licenseInfo.is_expiring_soon) {
                    remainingEl.style.color = '#e57373';
                } else {
                    remainingEl.style.color = '#81c995';
                }
            } else {
                remainingEl.textContent = '-';
                remainingEl.style.color = '';
            }
        }
        
        if (warningEl) {
            if (licenseInfo.is_expiring_soon) {
                warningEl.style.display = 'block';
                warningEl.textContent = `æˆæƒå°†åœ¨ ${licenseInfo.days_remaining} å¤©åè¿‡æœŸï¼Œè¯·åŠæ—¶ç»­è´¹`;
            } else {
                warningEl.style.display = 'none';
            }
        }
    } catch (error) {
        console.error('Error loading license settings info:', error);
    }
}

/**
 * Refresh license from server
 */
async function refreshLicense() {
    const statusEl = document.getElementById('license-refresh-status');
    const refreshBtn = document.getElementById('btn-refresh-license');
    
    if (statusEl) {
        statusEl.textContent = 'åˆ·æ–°ä¸­...';
        statusEl.className = 'license-refresh-status loading';
    }
    
    if (refreshBtn) {
        refreshBtn.disabled = true;
    }
    
    try {
        const result = await RefreshLicense();
        
        if (statusEl) {
            statusEl.textContent = 'âœ… åˆ·æ–°æˆåŠŸ';
            statusEl.className = 'license-refresh-status success';
        }
        
        // Reload the license info display
        await loadLicenseSettingsInfo();
        
        showToast('æˆæƒä¿¡æ¯å·²åˆ·æ–°', 'success');
    } catch (error) {
        console.error('Error refreshing license:', error);
        if (statusEl) {
            statusEl.textContent = 'âŒ åˆ·æ–°å¤±è´¥';
            statusEl.className = 'license-refresh-status error';
        }
        showToast('åˆ·æ–°æˆæƒå¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        if (refreshBtn) {
            refreshBtn.disabled = false;
        }
    }
}

/**
 * Open the settings modal and load current settings
 */
async function openSettings() {
    try {
        // Load current settings from backend
        const settings = await GetSettings();

        // Populate form fields
        settingApiKey.value = settings.openai_api_key || '';
        settingBaseUrl.value = settings.openai_base_url || 'https://api.openai.com/v1';
        settingModel.value = settings.openai_model || 'gpt-4';
        settingContextWindow.value = settings.context_window || 8192;
        settingCompiler.value = settings.default_compiler || 'pdflatex';
        settingWorkdir.value = settings.work_directory || '';
        settingConcurrency.value = settings.concurrency || 3;
        settingLibraryPageSize.value = settings.library_page_size || 20;
        
        // Share prompt setting (default to true if not set)
        settingSharePrompt.checked = settings.share_prompt_enabled !== false;

        // GitHub settings (only token, owner and repo use defaults)
        settingGitHubToken.value = settings.github_token || '';

        // Store original LLM settings to detect changes
        originalLlmSettings = {
            apiKey: settings.openai_api_key || '',
            baseUrl: settings.openai_base_url || 'https://api.openai.com/v1',
            model: settings.openai_model || 'gpt-4'
        };

        // If LLM is already configured (has API key), consider it as tested
        // User only needs to re-test if they change LLM settings
        apiTestPassed = (settings.openai_api_key && settings.openai_api_key.length > 0);

        // Reset test status display
        if (apiTestPassed) {
            testStatus.textContent = 'âœ… å·²é…ç½®';
            testStatus.className = 'test-status success';
        } else {
            testStatus.textContent = '';
            testStatus.className = 'test-status';
        }
        githubTestStatus.textContent = '';
        githubTestStatus.className = 'test-status';

        // Show modal
        settingsModal.classList.add('visible');

        // Adjust UI based on work mode (hide/show LLM tab)
        // Validates: Requirements 9.1, 9.2, 9.3
        await adjustSettingsUIForMode();

        // Reset to first visible tab
        // If LLM tab is hidden (commercial mode), select LaTeX tab instead
        const llmTabBtn = document.getElementById('settings-tab-btn-llm');
        const isLlmTabVisible = llmTabBtn && llmTabBtn.style.display !== 'none';
        
        document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
        
        if (isLlmTabVisible) {
            document.querySelector('.settings-tab[data-tab="llm"]').classList.add('active');
            document.getElementById('settings-tab-llm').classList.add('active');
        } else {
            document.querySelector('.settings-tab[data-tab="latex"]').classList.add('active');
            document.getElementById('settings-tab-latex').classList.add('active');
        }

        // Enable context menu for all input fields in settings modal
        const settingsInputs = settingsModal.querySelectorAll('input[type="text"], input[type="password"], input[type="number"], textarea');
        settingsInputs.forEach(input => {
            // Remove any existing listener to avoid duplicates
            input.removeEventListener('contextmenu', enableContextMenu);
            // Add context menu support
            input.addEventListener('contextmenu', enableContextMenu);
        });
    } catch (error) {
        console.error('Error loading settings:', error);
        showError('åŠ è½½è®¾ç½®å¤±è´¥');
    }
}

/**
 * Enable context menu for input elements
 */
function enableContextMenu(e) {
    e.stopPropagation(); // Allow default browser context menu
}

/**
 * Enable context menu for all input fields in the application
 */
function enableContextMenuForAllInputs() {
    // Select all input, textarea elements
    const allInputs = document.querySelectorAll('input[type="text"], input[type="password"], input[type="number"], input[type="url"], input[type="email"], textarea');
    
    allInputs.forEach(input => {
        input.addEventListener('contextmenu', enableContextMenu);
    });

    console.log(`Enabled context menu for ${allInputs.length} input fields`);
}

/**
 * Close the settings modal
 */
function closeSettings() {
    settingsModal.classList.remove('visible');
    apiTestPassed = false;
    
    // Reset first-time setup flag and cancel button behavior
    if (isFirstTimeSetup) {
        isFirstTimeSetup = false;
        // Reset cancel button to normal behavior
        if (btnSettingsCancel) {
            btnSettingsCancel.onclick = closeSettings;
        }
    }
}

/**
 * Open settings modal for first-time open source mode setup
 * Validates: Requirements 4.1, 4.2, 4.7
 */
function openSettingsForFirstTimeSetup() {
    isFirstTimeSetup = true;
    openSettings();
    
    // Modify cancel button behavior during first-time setup
    if (btnSettingsCancel) {
        btnSettingsCancel.onclick = () => {
            showExitConfirmDialog();
        };
    }
}

// Make it globally available for modeSelector.js
window.openSettingsForFirstTimeSetup = openSettingsForFirstTimeSetup;
window.openSettingsModal = openSettings;

/**
 * Show exit confirmation dialog during first-time setup
 * Returns to mode selection instead of exiting the app
 * Validates: Requirements 5.1, 5.2, 5.3, 5.4, 5.5
 */
function showExitConfirmDialog() {
    // Use existing confirm dialog
    if (genericConfirmModal) {
        // Set up the confirm dialog
        if (genericConfirmTitle) genericConfirmTitle.textContent = 'å–æ¶ˆé…ç½®';
        if (genericConfirmMessage) genericConfirmMessage.textContent = 'æ‚¨å°šæœªå®Œæˆ LLM é…ç½®ï¼Œç¡®å®šè¦è¿”å›æ¨¡å¼é€‰æ‹©å—ï¼Ÿ';
        if (btnGenericConfirm) {
            btnGenericConfirm.textContent = 'è¿”å›é€‰æ‹©';
            btnGenericConfirm.onclick = async () => {
                genericConfirmModal.classList.remove('visible');
                // Close settings modal
                settingsModal.classList.remove('visible');
                isFirstTimeSetup = false;
                apiTestPassed = false;
                
                // Clear the work mode so user can re-select
                try {
                    const { SetWorkMode } = await import('./modeSelector.js');
                    await SetWorkMode('');
                } catch (e) {
                    console.warn('Failed to clear work mode:', e);
                }
                
                // Show mode selection modal again
                const { showModeSelectionModal } = await import('./modeSelector.js');
                showModeSelectionModal();
            };
        }
        if (btnGenericCancel) {
            btnGenericCancel.textContent = 'ç»§ç»­é…ç½®';
            btnGenericCancel.onclick = () => {
                genericConfirmModal.classList.remove('visible');
            };
        }
        
        genericConfirmModal.classList.add('visible');
    } else {
        // Fallback: use browser confirm
        if (confirm('æ‚¨å°šæœªå®Œæˆ LLM é…ç½®ï¼Œç¡®å®šè¦è¿”å›æ¨¡å¼é€‰æ‹©å—ï¼Ÿ')) {
            settingsModal.classList.remove('visible');
            isFirstTimeSetup = false;
            // Try to show mode selection
            import('./modeSelector.js').then(({ showModeSelectionModal, SetWorkMode }) => {
                SetWorkMode('').then(() => showModeSelectionModal());
            });
        }
    }
}

/**
 * Open the about modal
 * Validates: Requirements 10.1, 10.6
 */
async function openAbout() {
    aboutModal.classList.add('visible');
    // Update license info for commercial mode
    await updateAboutLicenseInfo();
}

/**
 * Close the about modal
 */
function closeAbout() {
    aboutModal.classList.remove('visible');
}

/**
 * Open the results management modal
 */
async function openResults() {
    resultsModal.classList.add('visible');
    await loadPapersList();
}

/**
 * Close the results management modal
 */
function closeResults() {
    resultsModal.classList.remove('visible');
}

/**
 * Load and display the list of translated papers
 */
async function loadPapersList() {
    try {
        const papers = await ListTranslatedPapers();

        // Clear existing items (except the empty placeholder)
        const existingItems = resultsList.querySelectorAll('.paper-item');
        existingItems.forEach(item => item.remove());

        if (!papers || papers.length === 0) {
            resultsEmpty.style.display = 'block';
            return;
        }

        resultsEmpty.style.display = 'none';

        // Add paper items
        papers.forEach(paper => {
            const item = createPaperItem(paper);
            resultsList.appendChild(item);
        });
    } catch (error) {
        console.error('Failed to load papers list:', error);
        showToast('åŠ è½½è®ºæ–‡åˆ—è¡¨å¤±è´¥', 'error');
    }
}

/**
 * Create a paper item element
 */
function createPaperItem(paper) {
    const item = document.createElement('div');
    item.className = 'paper-item';
    item.dataset.arxivId = paper.arxiv_id;

    // Determine status display
    const status = paper.status || 'complete';
    const isComplete = status === 'complete';
    const isError = status === 'error';
    const statusText = getStatusText(status);
    const statusClass = isComplete ? 'status-complete' : (isError ? 'status-error' : 'status-pending');

    // Show continue button for incomplete/error translations
    const showContinue = !isComplete;
    const showView = isComplete || paper.original_pdf;
    const showShare = isComplete; // Only show share for completed translations

    item.innerHTML = `
        <span class="paper-icon">${isComplete ? 'ğŸ“„' : (isError ? 'âŒ' : 'â³')}</span>
        <div class="paper-info">
            <div class="paper-title" title="${escapeHtml(paper.title)}">${escapeHtml(paper.title)}</div>
            <div class="paper-meta">
                <span class="paper-arxiv-id">${escapeHtml(paper.arxiv_id)}</span>
                <span class="paper-status ${statusClass}">${statusText}</span>
                <span class="paper-date">${paper.translated_at}</span>
            </div>
            ${paper.error_message ? `<div class="paper-error" title="${escapeHtml(paper.error_message)}">é”™è¯¯: ${escapeHtml(paper.error_message.substring(0, 50))}${paper.error_message.length > 50 ? '...' : ''}</div>` : ''}
        </div>
        <div class="paper-actions">
            ${showView ? '<button class="paper-btn paper-btn-view" title="æŸ¥çœ‹">ğŸ‘ï¸ æŸ¥çœ‹</button>' : ''}
            ${showShare ? '<button class="paper-btn paper-btn-share" title="åˆ†äº«åˆ° GitHub">ğŸ“¤ åˆ†äº«</button>' : ''}
            ${showContinue ? '<button class="paper-btn paper-btn-continue" title="ç»§ç»­ç¿»è¯‘">â–¶ï¸ ç»§ç»­</button>' : ''}
            <button class="paper-btn paper-btn-retranslate" title="é‡æ–°ç¿»è¯‘">ğŸ”„ é‡è¯‘</button>
            <button class="paper-btn paper-btn-delete" title="åˆ é™¤">ğŸ—‘ï¸</button>
        </div>
    `;

    // Add event listeners
    if (showView) {
        item.querySelector('.paper-btn-view').addEventListener('click', () => viewPaper(paper.arxiv_id));
    }
    if (showShare) {
        item.querySelector('.paper-btn-share').addEventListener('click', () => sharePaper(paper.arxiv_id));
    }
    if (showContinue) {
        item.querySelector('.paper-btn-continue').addEventListener('click', () => continuePaper(paper.arxiv_id));
    }
    item.querySelector('.paper-btn-retranslate').addEventListener('click', () => retranslatePaper(paper.arxiv_id));
    item.querySelector('.paper-btn-delete').addEventListener('click', () => deletePaper(paper.arxiv_id, item));

    return item;
}

/**
 * Get human-readable status text
 */
function getStatusText(status) {
    const statusMap = {
        'pending': 'å¾…å¤„ç†',
        'downloading': 'ä¸‹è½½ä¸­',
        'extracted': 'å·²è§£å‹',
        'original_compiled': 'åŸæ–‡å·²ç¼–è¯‘',
        'translating': 'ç¿»è¯‘ä¸­',
        'translated': 'å·²ç¿»è¯‘',
        'compiling': 'ç¼–è¯‘ä¸­',
        'complete': 'å®Œæˆ',
        'error': 'é”™è¯¯'
    };
    return statusMap[status] || status;
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * View a previously translated paper
 */
async function viewPaper(arxivId) {
    try {
        closeResults();
        showToast('æ­£åœ¨åŠ è½½è®ºæ–‡...', 'info');

        const result = await OpenPaperResult(arxivId);
        if (result) {
            currentResult = result;
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';
            
            // Load PDFs with arXiv ID for URL bar update
            if (result.original_pdf_path) {
                loadPDF('left', result.original_pdf_path, arxivId);
            }
            if (result.translated_pdf_path) {
                loadPDF('right', result.translated_pdf_path, arxivId);
            }
            
            showToast('è®ºæ–‡åŠ è½½å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to view paper:', error);
        showToast('åŠ è½½è®ºæ–‡å¤±è´¥: ' + (error.message || error), 'error');
    }
}

// Store arxivId for paper share modal
let currentShareArxivId = null;

/**
 * Share a paper to GitHub from results list
 */
async function sharePaper(arxivId) {
    try {
        // Check share status for this specific paper
        const status = await CheckShareStatusForPaper(arxivId);

        if (!status.can_share) {
            showToast(status.message, 'warning');
            return;
        }

        // Store arxivId for later use
        currentShareArxivId = arxivId;

        // Update file names
        shareChineseName.textContent = status.chinese_pdf_path;
        shareBilingualName.textContent = status.bilingual_pdf_path;

        // Update status badges
        if (status.chinese_pdf_exists) {
            shareChineseStatus.textContent = 'å·²å­˜åœ¨';
            shareChineseStatus.className = 'file-status exists';
        } else {
            shareChineseStatus.textContent = 'æ–°æ–‡ä»¶';
            shareChineseStatus.className = 'file-status new';
        }

        if (status.bilingual_pdf_exists) {
            shareBilingualStatus.textContent = 'å·²å­˜åœ¨';
            shareBilingualStatus.className = 'file-status exists';
        } else {
            shareBilingualStatus.textContent = 'æ–°æ–‡ä»¶';
            shareBilingualStatus.className = 'file-status new';
        }

        // Show warning if any file exists
        if (status.chinese_pdf_exists || status.bilingual_pdf_exists) {
            shareWarning.style.display = 'flex';
        } else {
            shareWarning.style.display = 'none';
        }

        // Reset checkboxes
        shareChineseCheck.checked = true;
        shareBilingualCheck.checked = true;

        // Hide progress
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;

        // Show modal
        shareModal.classList.add('visible');
    } catch (error) {
        console.error('Failed to check share status:', error);
        showToast('æ£€æŸ¥åˆ†äº«çŠ¶æ€å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Re-translate a paper from arXiv
 */
async function retranslatePaper(arxivId) {
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç¿»è¯‘ä¸­
    if (isProcessing) {
        showToast('ç¿»è¯‘è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å½“å‰ç¿»è¯‘å®Œæˆåå†é‡è¯‘', 'warning');
        return;
    }

    const confirmed = await showConfirmDialog(
        `ç¡®å®šè¦é‡æ–°ç¿»è¯‘è®ºæ–‡ ${arxivId} å—ï¼Ÿ\n\nè¿™å°†ä» arXiv ä¸‹è½½æœ€æ–°ç‰ˆæœ¬å¹¶é‡æ–°ç¿»è¯‘ã€‚`,
        'ğŸ”„ é‡æ–°ç¿»è¯‘',
        'é‡æ–°ç¿»è¯‘',
        'å–æ¶ˆ'
    );
    if (!confirmed) {
        return;
    }

    try {
        closeResults();
        setProcessingState(true);
        resetPDFViewers();
        updateStatus('idle', 0, 'å¼€å§‹é‡æ–°ç¿»è¯‘...');
        startStatusPolling();

        const result = await RetranslateFromArxiv(arxivId);

        stopStatusPolling();

        if (result) {
            currentResult = result;
            updateStatus('complete', 100, 'é‡æ–°ç¿»è¯‘å®Œæˆ');
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';

            if (result.original_pdf_path) {
                loadPDF('left', result.original_pdf_path, arxivId);
            }
            if (result.translated_pdf_path) {
                loadPDF('right', result.translated_pdf_path, arxivId);
            }

            showToast('é‡æ–°ç¿»è¯‘å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to retranslate paper:', error);
        stopStatusPolling();
        updateStatus('error', 0, error.message || 'é‡æ–°ç¿»è¯‘å¤±è´¥');
        showToast('é‡æ–°ç¿»è¯‘å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        setProcessingState(false);
    }
}

/**
 * Continue a previously failed or incomplete translation
 */
async function continuePaper(arxivId) {
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç¿»è¯‘ä¸­
    if (isProcessing) {
        showToast('ç¿»è¯‘è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å½“å‰ç¿»è¯‘å®Œæˆåå†ç»§ç»­', 'warning');
        return;
    }

    try {
        closeResults();
        setProcessingState(true);
        resetPDFViewers();
        updateStatus('idle', 0, 'ç»§ç»­ç¿»è¯‘...');
        startStatusPolling();

        const result = await ContinueTranslation(arxivId);

        stopStatusPolling();

        if (result) {
            currentResult = result;
            updateStatus('complete', 100, 'ç¿»è¯‘å®Œæˆ');
            downloadDropdown.style.display = 'inline-block';
            btnShare.style.display = 'inline-block';

            if (result.original_pdf_path) {
                loadPDF('left', result.original_pdf_path, arxivId);
            }
            if (result.translated_pdf_path) {
                loadPDF('right', result.translated_pdf_path, arxivId);
            }

            showToast('ç¿»è¯‘å®Œæˆ', 'success');
        }
    } catch (error) {
        console.error('Failed to continue translation:', error);
        stopStatusPolling();
        updateStatus('error', 0, error.message || 'ç»§ç»­ç¿»è¯‘å¤±è´¥');
        showToast('ç»§ç»­ç¿»è¯‘å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        setProcessingState(false);
    }
}

/**
 * Delete a translated paper
 */
async function deletePaper(arxivId, itemElement) {
    const confirmed = await showConfirmDialog(
        `ç¡®å®šè¦åˆ é™¤è®ºæ–‡ ${arxivId} å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
        'ğŸ—‘ï¸ åˆ é™¤è®ºæ–‡',
        'åˆ é™¤',
        'å–æ¶ˆ'
    );
    if (!confirmed) {
        return;
    }

    try {
        await DeleteTranslatedPaper(arxivId);
        itemElement.remove();

        // Check if list is now empty
        const remainingItems = resultsList.querySelectorAll('.paper-item');
        if (remainingItems.length === 0) {
            resultsEmpty.style.display = 'block';
        }

        showToast('è®ºæ–‡å·²åˆ é™¤', 'success');
    } catch (error) {
        console.error('Failed to delete paper:', error);
        showToast('åˆ é™¤å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Open the share modal
 */
async function openShare() {
    try {
        // Clear any stored arxivId (this is for sharing from main view)
        currentShareArxivId = null;

        // Load categories if not loaded
        if (paperCategories.length === 0) {
            paperCategories = await GetPaperCategories();
        }
        
        // Populate category select
        populateCategorySelect(shareCategory, paperCategories);
        
        // Check share status first to get base file names
        const status = await CheckShareStatus();

        if (!status.can_share) {
            showToast(status.message, 'warning');
            return;
        }
        
        // Store base arXiv ID for file name generation
        const baseChineseName = status.chinese_pdf_path;
        const baseBilingualName = status.bilingual_pdf_path;
        
        // Add change event to show description, update file names, and check file status
        shareCategory.onchange = async () => {
            const selectedId = shareCategory.value;
            const category = paperCategories.find(c => c.id === selectedId);
            shareCategoryHint.textContent = category ? category.description : '';
            updateShareFileNames(baseChineseName, baseBilingualName);
            
            // Check file status for the selected category
            if (selectedId) {
                try {
                    const categoryStatus = await CheckShareStatusWithCategory(selectedId);
                    updateShareFileStatus(categoryStatus);
                } catch (error) {
                    console.warn('Failed to check category status:', error);
                }
            } else {
                // Reset to initial status when no category selected
                updateShareFileStatus(status);
            }
        };

        // Update file names (will be updated when category is selected)
        updateShareFileNames(baseChineseName, baseBilingualName);

        // Update status badges
        updateShareFileStatus(status);

        // Reset checkboxes
        shareChineseCheck.checked = true;
        shareBilingualCheck.checked = true;

        // Hide progress
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;

        // Show modal
        shareModal.classList.add('visible');
    } catch (error) {
        console.error('Failed to check share status:', error);
        showToast('æ£€æŸ¥åˆ†äº«çŠ¶æ€å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Populate category select dropdown
 */
function populateCategorySelect(selectElement, categories) {
    selectElement.innerHTML = '<option value="">-- è¯·é€‰æ‹©ç±»åˆ« --</option>';
    for (const cat of categories) {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        option.title = cat.description;
        selectElement.appendChild(option);
    }
}

/**
 * Update share file names based on selected category
 */
function updateShareFileNames(baseChinese, baseBilingual) {
    const categoryId = shareCategory.value;
    if (categoryId) {
        // Extract arxiv ID from base path (e.g., "2401.12345_cn.pdf" -> "2401.12345")
        const arxivMatch = baseChinese.match(/^([^_]+)/);
        const arxivId = arxivMatch ? arxivMatch[1] : baseChinese.replace('_cn.pdf', '');
        shareChineseName.textContent = `${arxivId}_${categoryId}_cn.pdf`;
        shareBilingualName.textContent = `${arxivId}_${categoryId}_bilingual.pdf`;
    } else {
        shareChineseName.textContent = baseChinese;
        shareBilingualName.textContent = baseBilingual;
    }
}

/**
 * Update share file status badges based on check result
 */
function updateShareFileStatus(status) {
    if (status.chinese_pdf_exists) {
        shareChineseStatus.textContent = 'å·²å­˜åœ¨';
        shareChineseStatus.className = 'file-status exists';
    } else {
        shareChineseStatus.textContent = 'æ–°æ–‡ä»¶';
        shareChineseStatus.className = 'file-status new';
    }

    if (status.bilingual_pdf_exists) {
        shareBilingualStatus.textContent = 'å·²å­˜åœ¨';
        shareBilingualStatus.className = 'file-status exists';
    } else {
        shareBilingualStatus.textContent = 'æ–°æ–‡ä»¶';
        shareBilingualStatus.className = 'file-status new';
    }

    // Show warning if any file exists
    if (status.chinese_pdf_exists || status.bilingual_pdf_exists) {
        shareWarning.style.display = 'flex';
    } else {
        shareWarning.style.display = 'none';
    }
}

/**
 * Close the share modal
 */
function closeShare() {
    shareModal.classList.remove('visible');
    currentShareArxivId = null; // Clear the stored arxivId
}

/**
 * Confirm and execute the share operation
 */
async function confirmShare() {
    const categoryId = shareCategory.value;
    const uploadChinese = shareChineseCheck.checked;
    const uploadBilingual = shareBilingualCheck.checked;

    if (!categoryId) {
        showToast('è¯·é€‰æ‹©è®ºæ–‡ç±»åˆ«', 'warning');
        return;
    }

    if (!uploadChinese && !uploadBilingual) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ä¸Šä¼ ', 'warning');
        return;
    }

    // Show progress
    shareProgress.style.display = 'flex';
    btnShareConfirm.disabled = true;

    try {
        let result;

        // If we have a specific arxivId (from results list), use SharePaperToGitHub
        if (currentShareArxivId) {
            result = await SharePaperToGitHub(currentShareArxivId, categoryId, uploadChinese, uploadBilingual);
        } else {
            // Otherwise use the current result (from main view)
            result = await ShareToGitHub(categoryId, uploadChinese, uploadBilingual);
        }

        if (result.success) {
            closeShare();

            let message = 'åˆ†äº«æˆåŠŸï¼';
            if (result.chinese_pdf_url) {
                message += '\nä¸­æ–‡ PDF: ' + result.chinese_pdf_url;
            }
            if (result.bilingual_pdf_url) {
                message += '\nåŒè¯­ PDF: ' + result.bilingual_pdf_url;
            }

            showToast('åˆ†äº«æˆåŠŸ', 'success');
        } else {
            showToast(result.message || 'åˆ†äº«å¤±è´¥', 'error');
        }
    } catch (error) {
        console.error('Failed to share:', error);
        showToast('åˆ†äº«å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        shareProgress.style.display = 'none';
        btnShareConfirm.disabled = false;
    }
}

/**
 * Update GitHub Token from remote
 */
async function updateGitHubToken() {
    githubUpdateStatus.textContent = 'â³ æ­£åœ¨è·å– Token...';
    githubUpdateStatus.className = 'test-status testing';
    btnUpdateGitHubToken.disabled = true;

    try {
        await UpdateGitHubToken();
        
        // Reload settings to show the new token
        const settings = await GetSettings();
        settingGitHubToken.value = settings.github_token || '';
        
        githubUpdateStatus.textContent = 'âœ… Token å·²æ›´æ–°';
        githubUpdateStatus.className = 'test-status success';
        showToast('GitHub Token å·²æˆåŠŸæ›´æ–°', 'success');
        
        // Clear status after 3 seconds
        setTimeout(() => {
            githubUpdateStatus.textContent = '';
            githubUpdateStatus.className = 'test-status';
        }, 3000);
    } catch (error) {
        console.error('Update GitHub token failed:', error);
        githubUpdateStatus.textContent = 'âŒ æ›´æ–°å¤±è´¥';
        githubUpdateStatus.className = 'test-status error';
        showToast('æ›´æ–° Token å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        btnUpdateGitHubToken.disabled = false;
    }
}

/**
 * Test GitHub connection
 */
async function testGitHubConnection() {
    const token = settingGitHubToken.value.trim();

    if (!token) {
        githubTestStatus.textContent = 'âŒ è¯·è¾“å…¥ GitHub Token';
        githubTestStatus.className = 'test-status error';
        return;
    }

    githubTestStatus.textContent = 'â³ æ­£åœ¨æµ‹è¯•...';
    githubTestStatus.className = 'test-status testing';
    btnTestGitHub.disabled = true;

    try {
        // Only pass token - owner and repo use defaults
        await TestGitHubConnection(token);
        githubTestStatus.textContent = 'âœ… è¿æ¥æˆåŠŸ';
        githubTestStatus.className = 'test-status success';
        showToast('GitHub è¿æ¥æµ‹è¯•æˆåŠŸ', 'success');
    } catch (error) {
        console.error('GitHub test failed:', error);
        githubTestStatus.textContent = 'âŒ ' + (error.message || 'è¿æ¥å¤±è´¥');
        githubTestStatus.className = 'test-status error';
        showToast('GitHub æµ‹è¯•å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        btnTestGitHub.disabled = false;
    }
}

/**
 * Perform startup environment check
 */
async function performStartupCheck() {
    console.log('Performing startup check...');

    // Reset UI to checking state
    resetStartupCheckUI();

    try {
        const result = await CheckStartupRequirements();
        console.log('Startup check result:', result);

        // Update LaTeX check result
        updateLatexCheckResult(result.latex_installed, result.latex_version);

        // Update LLM check result
        updateLlmCheckResult(result.llm_configured, result.llm_error);

        // Enable continue button if all checks pass
        btnContinue.disabled = !(result.latex_installed && result.llm_configured);

    } catch (error) {
        console.error('Startup check error:', error);
        // Show error state
        updateLatexCheckResult(false, 'æ£€æµ‹å¤±è´¥: ' + (error.message || error));
        updateLlmCheckResult(false, 'æ£€æµ‹å¤±è´¥');
    }
}

/**
 * Reset startup check UI to initial state
 */
function resetStartupCheckUI() {
    // Reset LaTeX check
    latexSpinner.style.display = 'inline-block';
    latexStatus.style.display = 'none';
    latexDetail.textContent = 'æ£€æµ‹ä¸­...';
    latexAction.style.display = 'none';
    checkLatexItem.classList.remove('success', 'error');

    // Reset LLM check
    llmSpinner.style.display = 'inline-block';
    llmStatus.style.display = 'none';
    llmDetail.textContent = 'æ£€æµ‹ä¸­...';
    llmAction.style.display = 'none';
    checkLlmItem.classList.remove('success', 'error');

    // Disable continue button
    btnContinue.disabled = true;
}

/**
 * Update LaTeX check result in UI
 */
function updateLatexCheckResult(installed, version) {
    latexSpinner.style.display = 'none';
    latexStatus.style.display = 'inline';

    if (installed) {
        latexStatus.textContent = 'âœ…';
        latexDetail.textContent = version || 'å·²å®‰è£…';
        checkLatexItem.classList.add('success');
        checkLatexItem.classList.remove('error');
        latexAction.style.display = 'none';
    } else {
        latexStatus.textContent = 'âŒ';
        latexDetail.textContent = 'æœªæ£€æµ‹åˆ° LaTeX ç¼–è¯‘å™¨';
        checkLatexItem.classList.add('error');
        checkLatexItem.classList.remove('success');
        latexAction.style.display = 'block';
    }
}

/**
 * Update LLM check result in UI
 */
function updateLlmCheckResult(configured, error) {
    llmSpinner.style.display = 'none';
    llmStatus.style.display = 'inline';

    if (configured) {
        llmStatus.textContent = 'âœ…';
        llmDetail.textContent = 'LLM é…ç½®æ­£ç¡®ï¼Œè¿æ¥æµ‹è¯•é€šè¿‡';
        checkLlmItem.classList.add('success');
        checkLlmItem.classList.remove('error');
        llmAction.style.display = 'none';
    } else {
        llmStatus.textContent = 'âŒ';
        llmDetail.textContent = error || 'LLM æœªé…ç½®æˆ–è¿æ¥å¤±è´¥';
        checkLlmItem.classList.add('error');
        checkLlmItem.classList.remove('success');
        llmAction.style.display = 'block';
    }
}

/**
 * Show startup check modal
 */
function showStartupCheckModal() {
    startupCheckModal.classList.add('visible');
}

/**
 * Close startup check modal
 */
function closeStartupCheckModal() {
    startupCheckModal.classList.remove('visible');
}

/**
 * Reset test status when LLM settings change
 * Only resets if the settings actually changed from the original values
 */
function resetTestStatus() {
    const currentApiKey = settingApiKey.value.trim();
    const currentBaseUrl = settingBaseUrl.value.trim();
    const currentModel = settingModel.value.trim();

    // Check if LLM settings have changed from original
    const llmChanged = (
        currentApiKey !== originalLlmSettings.apiKey ||
        currentBaseUrl !== originalLlmSettings.baseUrl ||
        currentModel !== originalLlmSettings.model
    );

    if (llmChanged) {
        apiTestPassed = false;
        testStatus.textContent = 'âš ï¸ é…ç½®å·²ä¿®æ”¹ï¼Œè¯·é‡æ–°æµ‹è¯•';
        testStatus.className = 'test-status warning';
    }
}

/**
 * Browse for work directory
 */
async function browseWorkdir() {
    try {
        const result = await OpenDirectoryDialog();
        if (result) {
            settingWorkdir.value = result;
        }
    } catch (error) {
        console.error('Error opening directory dialog:', error);
    }
}

/**
 * Test API connection
 */
async function testConnection() {
    const apiKey = settingApiKey.value.trim();
    const baseUrl = settingBaseUrl.value.trim();
    const model = settingModel.value.trim();

    // Validate required fields
    if (!apiKey) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥ API Key';
        testStatus.className = 'test-status error';
        return;
    }
    if (!baseUrl) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥ API Base URL';
        testStatus.className = 'test-status error';
        return;
    }
    if (!model) {
        testStatus.textContent = 'âŒ è¯·è¾“å…¥æ¨¡å‹åç§°';
        testStatus.className = 'test-status error';
        return;
    }

    // Show testing status
    testStatus.textContent = 'â³ æ­£åœ¨æµ‹è¯• LLM è¿æ¥...';
    testStatus.className = 'test-status testing';
    btnTestConnection.disabled = true;

    try {
        await TestAPIConnection(apiKey, baseUrl, model);
        testStatus.textContent = 'âœ… LLM æµ‹è¯•æˆåŠŸ';
        testStatus.className = 'test-status success';
        apiTestPassed = true;
        showToast('LLM è¿æ¥æµ‹è¯•æˆåŠŸ', 'success');
    } catch (error) {
        console.error('API test failed:', error);
        const errorMsg = error.message || error.toString() || 'è¿æ¥å¤±è´¥';
        testStatus.textContent = 'âŒ ' + errorMsg;
        testStatus.className = 'test-status error';
        apiTestPassed = false;
        showToast('LLM æµ‹è¯•å¤±è´¥: ' + errorMsg, 'error', 5000);
    } finally {
        btnTestConnection.disabled = false;
    }
}

/**
 * Save settings to backend
 */
async function saveSettings() {
    const apiKey = settingApiKey.value.trim();
    const baseUrl = settingBaseUrl.value.trim();
    const model = settingModel.value.trim();

    // Get current work mode to determine if LLM validation is needed
    let workMode = '';
    try {
        workMode = await GetWorkMode();
    } catch (e) {
        console.warn('Failed to get work mode:', e);
    }
    
    const isCommercialMode = workMode === 'commercial';

    // Check if LLM settings have changed
    const llmChanged = (
        apiKey !== originalLlmSettings.apiKey ||
        baseUrl !== originalLlmSettings.baseUrl ||
        model !== originalLlmSettings.model
    );

    // For first-time setup in opensource mode, MUST test LLM connection
    // Validates: Requirements 4.1, 4.2, 4.7
    if (isFirstTimeSetup && !isCommercialMode) {
        if (!apiKey) {
            showToast('å¼€æºæ¨¡å¼å¿…é¡»é…ç½® LLM API Key', 'warning');
            return;
        }
        if (!apiTestPassed) {
            showToast('å¼€æºæ¨¡å¼å¿…é¡»å…ˆæµ‹è¯• LLM è¿æ¥å¹¶é€šè¿‡', 'warning');
            return;
        }
    }

    // Only require LLM test if LLM settings changed and test hasn't passed
    // Skip this check in commercial mode (LLM is provided by license)
    if (!isCommercialMode && llmChanged && !apiTestPassed) {
        showToast('LLM é…ç½®å·²ä¿®æ”¹ï¼Œè¯·å…ˆæµ‹è¯•è¿æ¥', 'warning');
        return;
    }

    // If no API key at all, warn user (only in opensource mode)
    if (!isCommercialMode && !apiKey && !originalLlmSettings.apiKey) {
        showToast('è¯·é…ç½® LLM API Key', 'warning');
        return;
    }

    try {
        const contextWindow = parseInt(settingContextWindow.value) || 8192;
        const compiler = settingCompiler.value;
        const workDir = settingWorkdir.value.trim();
        const concurrency = parseInt(settingConcurrency.value) || 3;
        
        // Parse library page size, ensure it's at least 1
        let libraryPageSize = parseInt(settingLibraryPageSize.value);
        if (isNaN(libraryPageSize) || libraryPageSize < 1) {
            libraryPageSize = 20;
        }
        
        // Share prompt setting
        const sharePromptEnabled = settingSharePrompt.checked;
        
        console.log('Saving settings with libraryPageSize:', libraryPageSize, 'sharePromptEnabled:', sharePromptEnabled);

        // GitHub settings (use defaults for owner and repo)
        const githubToken = settingGitHubToken.value.trim();
        const githubOwner = DEFAULT_GITHUB_OWNER;
        const githubRepo = DEFAULT_GITHUB_REPO;

        // Save to backend
        await SaveSettings(apiKey, baseUrl, model, contextWindow, compiler, workDir, concurrency, githubToken, githubOwner, githubRepo, libraryPageSize, sharePromptEnabled);

        // Handle first-time setup completion
        // Validates: Requirements 4.4, 4.5
        const wasFirstTimeSetup = isFirstTimeSetup;
        
        // Close modal (this also resets isFirstTimeSetup flag)
        closeSettings();

        // Show success message
        if (wasFirstTimeSetup) {
            showToast('é…ç½®å®Œæˆï¼Œæ¬¢è¿ä½¿ç”¨ï¼', 'success');
        } else {
            showToast('è®¾ç½®å·²ä¿å­˜', 'success');
        }
    } catch (error) {
        console.error('Error saving settings:', error);
        showToast('ä¿å­˜è®¾ç½®å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Initialize the application
 */
async function init() {
    // Load cached paper metadata from localStorage
    loadMetadataCache();
    
    // Initialize DOM elements
    initElements();

    // Initialize backend bindings
    await initBindings();

    // Make showToast available globally for error management module
    window.showToast = showToast;

    // Initialize error management
    initErrorManagement({
        ListErrors,
        RetryFromError,
        ClearError,
        ClearAllErrors,
        ExportErrorsToFile,
        ExportErrorIDsToFile,
        ReportErrorsToGitHub,
        // é‡è¯•æ—¶æ›´æ–°è¾“å…¥æ¡†å¹¶å¯åŠ¨çŠ¶æ€è½®è¯¢
        onRetryUpdateInput: (input) => {
            // æ›´æ–°è¾“å…¥æ¡†
            if (inputSource) {
                inputSource.value = input;
            }
            // è®¾ç½®å¤„ç†çŠ¶æ€
            setProcessingState(true);
            resetPDFViewers();
            updateStatus('idle', 0, 'é‡è¯•ç¿»è¯‘ä¸­...');
            // å¯åŠ¨çŠ¶æ€è½®è¯¢
            startStatusPolling();
        },
        // é‡è¯•å®Œæˆå›è°ƒ
        onRetryComplete: (result, error) => {
            // åœæ­¢çŠ¶æ€è½®è¯¢
            stopStatusPolling();
            
            if (error) {
                // é‡è¯•å¤±è´¥
                const errorMsg = error.message || error.toString() || 'é‡è¯•å¤±è´¥';
                updateStatus('error', 0, errorMsg);
                setProcessingState(false);
            } else if (result) {
                // é‡è¯•æˆåŠŸï¼Œå¤„ç†ç»“æœ
                handleProcessResult(result);
            } else {
                // æ²¡æœ‰ç»“æœä¹Ÿæ²¡æœ‰é”™è¯¯
                setProcessingState(false);
            }
        }
    });

    // Set up event listeners
    setupEventListeners();

    // Enable context menu for all input fields globally
    enableContextMenuForAllInputs();

    // Initialize mode selector bindings
    await initModeBindings();

    // Check work mode first - this may show mode selection modal
    // Validates: Requirements 1.1, 1.2
    const modeConfigured = await checkStartupMode();
    
    if (!modeConfigured) {
        // Mode selection is needed, wait for user to complete it
        // The mode selector will handle showing the appropriate modal
        console.log('Work mode not configured, waiting for user selection');
        return;
    }

    // Perform startup environment check (after mode is configured)
    await performStartupCheckOnInit();

    // Load last input
    try {
        const lastInput = await GetLastInput();
        if (lastInput) {
            inputSource.value = lastInput;
        }
    } catch (error) {
        console.warn('Failed to load last input:', error);
    }

    // Set initial state
    updateStatus('idle', 0, 'å°±ç»ª');

    console.log('LaTeX ç¿»è¯‘å™¨å‰ç«¯å·²åˆå§‹åŒ–');
}

/**
 * Continue initialization after mode selection is complete
 * Called from modeSelector.js after successful activation or mode selection
 * Validates: Requirements 1.1, 1.2
 */
async function initMainInterface() {
    console.log('Continuing initialization after mode selection...');
    
    // Perform startup environment check
    await performStartupCheckOnInit();

    // Load last input
    try {
        const lastInput = await GetLastInput();
        if (lastInput) {
            inputSource.value = lastInput;
        }
    } catch (error) {
        console.warn('Failed to load last input:', error);
    }

    // Set initial state
    updateStatus('idle', 0, 'å°±ç»ª');

    console.log('Main interface initialized');
}

// Make initMainInterface globally available for modeSelector.js
window.initMainInterface = initMainInterface;

/**
 * Perform startup check on initialization
 * Shows modal if any check fails
 * Validates: Requirements 1.1, 1.4, 1.5
 */
async function performStartupCheckOnInit() {
    try {
        // Get current work mode to determine what to check
        const workMode = await GetWorkMode();
        console.log('Current work mode for startup check:', workMode);
        
        const result = await CheckStartupRequirements();
        console.log('Initial startup check result:', result);

        // In commercial mode, LLM is pre-configured, so we only check LaTeX
        // In opensource mode, we check both LaTeX and LLM
        const needsLlmCheck = workMode !== 'commercial';
        const llmOk = !needsLlmCheck || result.llm_configured;

        // If any required check fails, show the modal
        if (!result.latex_installed || !llmOk) {
            showStartupCheckModal();

            // Update UI with results
            updateLatexCheckResult(result.latex_installed, result.latex_version);
            
            if (needsLlmCheck) {
                updateLlmCheckResult(result.llm_configured, result.llm_error);
            } else {
                // Commercial mode: mark LLM as configured (handled by license)
                updateLlmCheckResult(true, 'å•†ä¸šæˆæƒå·²é…ç½®');
            }

            // Enable continue button if all required checks pass
            btnContinue.disabled = !(result.latex_installed && llmOk);
        }
    } catch (error) {
        console.error('Initial startup check error:', error);
        // Show modal with error state
        showStartupCheckModal();
        updateLatexCheckResult(false, 'æ£€æµ‹å¤±è´¥');
        updateLlmCheckResult(false, 'æ£€æµ‹å¤±è´¥');
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// ============================================
// PDF Translation Mode Functions
// ============================================

/**
 * Set up event listeners for PDF translation mode
 * Validates: Requirements 1.1, 1.2, 3.5, 5.5, 5.3, 5.6
 */
function setupPdfModeEventListeners() {
    // Mode tab switching
    if (modeTabLatex) {
        modeTabLatex.addEventListener('click', () => switchMode('latex'));
    }
    if (modeTabPdf) {
        modeTabPdf.addEventListener('click', () => switchMode('pdf'));
    }

    // PDF file selection button
    if (btnSelectPdf) {
        btnSelectPdf.addEventListener('click', handleSelectPdf);
    }

    // PDF drop zone drag and drop events
    if (pdfDropZone) {
        pdfDropZone.addEventListener('dragover', handlePdfDragOver);
        pdfDropZone.addEventListener('dragleave', handlePdfDragLeave);
        pdfDropZone.addEventListener('drop', handlePdfDrop);
        // Also allow clicking the drop zone to select file
        pdfDropZone.addEventListener('click', (e) => {
            // Don't trigger if clicking the button inside
            if (e.target !== btnSelectPdf && !btnSelectPdf.contains(e.target)) {
                handleSelectPdf();
            }
        });
    }

    // Clear selected PDF button
    if (btnClearPdf) {
        btnClearPdf.addEventListener('click', clearSelectedPdf);
    }

    // Start PDF translation button
    if (btnTranslatePdf) {
        btnTranslatePdf.addEventListener('click', handleTranslatePdf);
    }

    // Download translated PDF button
    // Validates: Requirements 5.6
    if (btnDownloadTranslated) {
        btnDownloadTranslated.addEventListener('click', handleDownloadTranslatedPdf);
    }

    // Set up sync scrolling between PDF iframes
    // Validates: Requirements 5.3
    setupPdfSyncScrolling();

    // Listen for PDF translation status updates
    EventsOn('pdf-status-update', handlePdfStatusUpdate);

    // Listen for progressive PDF page translation updates
    // When a page is translated, reload the PDF to show progress
    EventsOn('pdf-page-translated', (data) => {
        console.log('PDF page translated:', data);
        if (data && data.outputPath) {
            // Only update if we're in PDF mode
            if (currentMode === 'pdf') {
                // Reload the right PDF iframe to show the translated pages
                // Add timestamp to bust browser cache
                const cacheBustPath = data.outputPath + '?t=' + Date.now();
                loadPDF('right', cacheBustPath);
                
                // Update status message to show progress
                const message = `å·²ç¿»è¯‘ ${data.currentPage}/${data.totalPages} é¡µ`;
                updateStatus('translating', Math.round((data.currentPage / data.totalPages) * 100), message);
            }
        }
    });
}

/**
 * Switch between LaTeX and PDF translation modes
 * @param {string} mode - 'latex' or 'pdf'
 * Validates: Requirements 5.1
 */
function switchMode(mode) {
    if (mode === currentMode) return;

    // åˆ‡æ¢å‰ä¿å­˜å½“å‰æ¨¡å¼çš„ PDF è·¯å¾„ï¼ˆåªä¿å­˜æœ‰æ•ˆçš„ PDF è·¯å¾„ï¼‰
    if (currentMode === 'latex') {
        // ä¿å­˜ LaTeX æ¨¡å¼çš„ PDF è·¯å¾„
        const leftSrc = pdfLeftIframe.src;
        const rightSrc = pdfRightIframe.src;
        latexModeLeftPdf = (leftSrc && leftSrc !== 'about:blank' && leftSrc.includes('/pdf/')) ? leftSrc : null;
        latexModeRightPdf = (rightSrc && rightSrc !== 'about:blank' && rightSrc.includes('/pdf/')) ? rightSrc : null;
    } else {
        // ä¿å­˜ PDF æ¨¡å¼çš„ PDF è·¯å¾„
        const leftSrc = pdfLeftIframe.src;
        const rightSrc = pdfRightIframe.src;
        pdfModeLeftPdf = (leftSrc && leftSrc !== 'about:blank' && leftSrc.includes('/pdf/')) ? leftSrc : null;
        pdfModeRightPdf = (rightSrc && rightSrc !== 'about:blank' && rightSrc.includes('/pdf/')) ? rightSrc : null;
    }

    currentMode = mode;

    // Update tab active states
    if (modeTabLatex && modeTabPdf) {
        modeTabLatex.classList.toggle('active', mode === 'latex');
        modeTabPdf.classList.toggle('active', mode === 'pdf');
    }

    // Show/hide input sections
    if (latexInputSection && pdfInputSection) {
        latexInputSection.style.display = mode === 'latex' ? 'flex' : 'none';
        pdfInputSection.classList.toggle('visible', mode === 'pdf');
    }

    // æ¢å¤ç›®æ ‡æ¨¡å¼çš„ PDF è·¯å¾„
    if (mode === 'latex') {
        restoreLatexModeState();
    } else {
        restorePdfModeState();
    }
}

/**
 * æ¢å¤ LaTeX æ¨¡å¼çš„çŠ¶æ€
 */
function restoreLatexModeState() {
    // æ¢å¤çŠ¶æ€æ 
    applyStatusDisplay(latexModeStatus);

    // æ¢å¤è¿›åº¦æ¡å¯è§æ€§
    if (isProcessing) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }

    // æ¢å¤å·¦ä¾§ PDF
    if (latexModeLeftPdf) {
        pdfLeftPlaceholder.style.display = 'none';
        pdfLeftIframe.style.display = 'block';
        pdfLeftIframe.src = latexModeLeftPdf;
    } else {
        pdfLeftIframe.src = 'about:blank';
        pdfLeftIframe.style.display = 'none';
        pdfLeftPlaceholder.style.display = 'flex';
    }

    // æ¢å¤å³ä¾§ PDF
    if (latexModeRightPdf) {
        pdfRightPlaceholder.style.display = 'none';
        pdfRightIframe.style.display = 'block';
        pdfRightIframe.src = latexModeRightPdf;
    } else {
        pdfRightIframe.src = 'about:blank';
        pdfRightIframe.style.display = 'none';
        pdfRightPlaceholder.style.display = 'flex';
    }

    // æ¢å¤ä¸‹è½½æŒ‰é’®çŠ¶æ€
    if (currentResult) {
        downloadDropdown.style.display = 'inline-block';
        btnShare.style.display = 'inline-block';
    } else {
        downloadDropdown.style.display = 'none';
        btnShare.style.display = 'none';
    }
    hideDownloadTranslatedButton();
}

/**
 * æ¢å¤ PDF æ¨¡å¼çš„çŠ¶æ€
 */
function restorePdfModeState() {
    // æ¢å¤çŠ¶æ€æ 
    applyStatusDisplay(pdfModeStatus);

    // æ¢å¤è¿›åº¦æ¡å¯è§æ€§
    if (isPdfTranslating) {
        progressContainer.classList.add('visible');
    } else {
        progressContainer.classList.remove('visible');
    }

    // éšè— LaTeX æ¨¡å¼çš„ä¸‹è½½æŒ‰é’®
    downloadDropdown.style.display = 'none';
    btnShare.style.display = 'none';

    // æ¢å¤å·¦ä¾§ PDF
    if (pdfModeLeftPdf) {
        pdfLeftPlaceholder.style.display = 'none';
        pdfLeftIframe.style.display = 'block';
        pdfLeftIframe.src = pdfModeLeftPdf;
    } else {
        pdfLeftIframe.src = 'about:blank';
        pdfLeftIframe.style.display = 'none';
        pdfLeftPlaceholder.style.display = 'flex';
    }

    // æ¢å¤å³ä¾§ PDF
    if (pdfModeRightPdf) {
        pdfRightPlaceholder.style.display = 'none';
        pdfRightIframe.style.display = 'block';
        pdfRightIframe.src = pdfModeRightPdf;
        showDownloadTranslatedButton(pdfModeRightPdf.replace('/pdf/', ''));
    } else {
        pdfRightIframe.src = 'about:blank';
        pdfRightIframe.style.display = 'none';
        pdfRightPlaceholder.style.display = 'flex';
        hideDownloadTranslatedButton();
    }

    // æ¢å¤æ–‡ä»¶é€‰æ‹©åŒºåŸŸçŠ¶æ€
    if (currentPdfFilePath && currentPdfInfo) {
        showSelectedPdfFile(currentPdfInfo);
    } else {
        if (pdfFileSelected) {
            pdfFileSelected.classList.remove('visible');
        }
        if (pdfDropZone) {
            pdfDropZone.style.display = 'block';
        }
    }
}

/**
 * Handle PDF file selection via dialog
 * Validates: Requirements 1.1
 */
async function handleSelectPdf() {
    try {
        const filePath = await OpenPDFFileDialog();
        if (filePath) {
            await loadPdfFile(filePath);
        }
    } catch (error) {
        console.error('Error selecting PDF file:', error);
        showError('é€‰æ‹© PDF æ–‡ä»¶å¤±è´¥: ' + (error.message || error), 'pdf');
    }
}

/**
 * Handle drag over event for PDF drop zone
 * @param {DragEvent} e - Drag event
 * Validates: Requirements 1.2
 */
function handlePdfDragOver(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.add('drag-over');
}

/**
 * Handle drag leave event for PDF drop zone
 * @param {DragEvent} e - Drag event
 * Validates: Requirements 1.2
 */
function handlePdfDragLeave(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.remove('drag-over');
}

/**
 * Handle drop event for PDF drop zone
 * @param {DragEvent} e - Drop event
 * Validates: Requirements 1.2
 */
async function handlePdfDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    pdfDropZone.classList.remove('drag-over');

    const files = e.dataTransfer.files;
    if (files.length === 0) {
        return;
    }

    const file = files[0];

    // Check if it's a PDF file
    if (!file.name.toLowerCase().endsWith('.pdf')) {
        showError('è¯·é€‰æ‹© PDF æ–‡ä»¶', 'pdf');
        return;
    }

    // For drag and drop, we need to get the file path
    // In Wails, we can use the file path from the dataTransfer
    // However, web browsers don't expose the full path for security reasons
    // We need to use the Wails file dialog instead
    showToast('æ‹–æ‹½åŠŸèƒ½æš‚ä¸æ”¯æŒï¼Œè¯·ä½¿ç”¨"é€‰æ‹© PDF æ–‡ä»¶"æŒ‰é’®', 'warning');
}

/**
 * Load a PDF file and display its info
 * @param {string} filePath - Path to the PDF file
 * Validates: Requirements 1.1, 1.4
 */
async function loadPdfFile(filePath) {
    try {
        updateStatus('loading', 0, 'æ­£åœ¨åŠ è½½ PDF æ–‡ä»¶...');

        // Call backend to load PDF
        const pdfInfo = await LoadPDF(filePath);

        if (!pdfInfo) {
            throw new Error('æ— æ³•åŠ è½½ PDF æ–‡ä»¶');
        }

        // Check if it's a text PDF
        if (!pdfInfo.is_text_pdf) {
            showError('è¯¥ PDF ä¸ºæ‰«æä»¶ï¼Œä¸æ”¯æŒç›´æ¥ç¿»è¯‘', 'pdf');
            pdfModeStatus = { phase: 'error', progress: 0, message: 'ä¸æ”¯æŒçš„ PDF æ ¼å¼', error: 'ä¸æ”¯æŒçš„ PDF æ ¼å¼' };
            if (currentMode === 'pdf') {
                applyStatusDisplay(pdfModeStatus);
            }
            return;
        }

        // Store the PDF info and path
        currentPdfInfo = pdfInfo;
        currentPdfFilePath = filePath;

        // Update UI to show selected file
        showSelectedPdfFile(pdfInfo);

        // Load the original PDF in the left viewer
        loadPDF('left', filePath);

        pdfModeStatus = { phase: 'idle', progress: 0, message: 'PDF æ–‡ä»¶å·²åŠ è½½ï¼Œå¯ä»¥å¼€å§‹ç¿»è¯‘', error: null };
        if (currentMode === 'pdf') {
            applyStatusDisplay(pdfModeStatus);
        }
        showToast(`å·²åŠ è½½: ${pdfInfo.file_name} (${pdfInfo.page_count} é¡µ)`, 'success');

    } catch (error) {
        console.error('Error loading PDF:', error);
        showError('åŠ è½½ PDF å¤±è´¥: ' + (error.message || error), 'pdf');
        pdfModeStatus = { phase: 'error', progress: 0, message: 'åŠ è½½å¤±è´¥', error: 'åŠ è½½å¤±è´¥' };
        if (currentMode === 'pdf') {
            applyStatusDisplay(pdfModeStatus);
        }
    }
}

/**
 * Show selected PDF file info in the UI
 * @param {Object} pdfInfo - PDF file information
 * Validates: Requirements 1.4
 */
function showSelectedPdfFile(pdfInfo) {
    if (!pdfFileSelected || !pdfFileName || !pdfFileSize) return;

    // Update file info display
    pdfFileName.textContent = pdfInfo.file_name || 'Unknown';
    pdfFileSize.textContent = formatFileSize(pdfInfo.file_size) + ` Â· ${pdfInfo.page_count} é¡µ`;

    // Show the selected file container, hide drop zone
    pdfFileSelected.classList.add('visible');
    if (pdfDropZone) {
        pdfDropZone.style.display = 'none';
    }
}

/**
 * Clear the selected PDF file
 */
function clearSelectedPdf() {
    currentPdfInfo = null;
    currentPdfFilePath = null;
    currentPdfTranslatedPath = null; // æ¸…é™¤ç¿»è¯‘åçš„ PDF è·¯å¾„

    // Hide selected file container, show drop zone
    if (pdfFileSelected) {
        pdfFileSelected.classList.remove('visible');
    }
    if (pdfDropZone) {
        pdfDropZone.style.display = 'block';
    }

    // Reset PDF viewers
    resetPDFViewers();

    // Hide download button
    hideDownloadTranslatedButton();

    // Reset status
    updateStatus('idle', 0, 'å°±ç»ª');
}

/**
 * Format file size to human readable string
 * @param {number} bytes - File size in bytes
 * @returns {string} Formatted file size
 */
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Handle PDF translation button click
 * Validates: Requirements 3.5, 5.5, 5.6
 */
async function handleTranslatePdf() {
    if (!currentPdfFilePath) {
        showError('è¯·å…ˆé€‰æ‹© PDF æ–‡ä»¶', 'pdf');
        return;
    }

    if (isPdfTranslating) {
        return;
    }

    // Update UI to translating state
    setPdfTranslatingState(true);
    // ç›´æ¥æ›´æ–° PDF æ¨¡å¼çŠ¶æ€
    pdfModeStatus = { phase: 'translating', progress: 0, message: 'å¼€å§‹ç¿»è¯‘...', error: null };
    if (currentMode === 'pdf') {
        applyStatusDisplay(pdfModeStatus);
    }

    // Hide download button while translating
    hideDownloadTranslatedButton();

    try {
        // Start status polling
        startPdfStatusPolling();

        // Call backend to start translation
        const result = await TranslatePDF();

        // Stop status polling
        stopPdfStatusPolling();

        if (result) {
            // Translation completed successfully
            // ç›´æ¥æ›´æ–° PDF æ¨¡å¼çŠ¶æ€
            pdfModeStatus = { phase: 'complete', progress: 100, message: 'ç¿»è¯‘å®Œæˆ', error: null };
            if (currentMode === 'pdf') {
                applyStatusDisplay(pdfModeStatus);
            }

            // Load translated PDF in the right viewer
            if (result.translated_pdf_path) {
                // ä¿å­˜ç¿»è¯‘åçš„ PDF è·¯å¾„ï¼Œç”¨äºæ¨¡å¼åˆ‡æ¢æ—¶æ¢å¤
                currentPdfTranslatedPath = result.translated_pdf_path;
                loadPDF('right', result.translated_pdf_path);
                // Show download button for translated PDF
                // Validates: Requirements 5.6
                showDownloadTranslatedButton(result.translated_pdf_path);
            }

            showToast(`ç¿»è¯‘å®Œæˆï¼å…±ç¿»è¯‘ ${result.translated_blocks} ä¸ªæ–‡æœ¬å—`, 'success');
        }
    } catch (error) {
        console.error('PDF translation error:', error);
        stopPdfStatusPolling();

        const errorMsg = error.message || error.toString() || 'ç¿»è¯‘å¤±è´¥';
        // Save to PDF mode status
        pdfModeStatus = { phase: 'error', progress: 0, message: errorMsg, error: errorMsg };
        if (currentMode === 'pdf') {
            applyStatusDisplay(pdfModeStatus);
        }
        showError(errorMsg, 'pdf');
    } finally {
        setPdfTranslatingState(false);
    }
}

/**
 * Handle PDF status update from backend event
 * @param {Object} status - PDF status object from backend
 * Validates: Requirements 3.5, 5.5
 */
function handlePdfStatusUpdate(status) {
    if (status) {
        updatePdfStatus(status);
    }
}

/**
 * Update the PDF translation status display
 * @param {Object} status - PDF status object
 * Validates: Requirements 3.5, 5.5
 */
function updatePdfStatus(status) {
    const phase = status.phase || 'idle';
    const progress = status.progress || 0;
    let message = status.message || '';

    // Add block progress info if available, but not if we're showing page progress
    // (page progress messages contain "é¡µ")
    if (status.total_blocks > 0 && !message.includes('é¡µ')) {
        message = `${message} (${status.completed_blocks}/${status.total_blocks} å—)`;
    }

    // Always save to PDF mode status
    pdfModeStatus = { 
        phase: phase, 
        progress: progress, 
        message: message || 'å°±ç»ª', 
        error: status.error || null 
    };
    
    // Only update display if we're in PDF mode
    if (currentMode === 'pdf') {
        applyStatusDisplay(pdfModeStatus);
    }
}

/**
 * Start polling for PDF translation status
 * Validates: Requirements 3.5, 5.5
 */
function startPdfStatusPolling() {
    // Poll every 500ms
    pdfStatusPollInterval = setInterval(async () => {
        try {
            const status = await GetPDFStatus();
            if (status) {
                updatePdfStatus(status);
            }
        } catch (error) {
            console.error('PDF status poll error:', error);
        }
    }, 500);
}

/**
 * Stop polling for PDF translation status
 */
function stopPdfStatusPolling() {
    if (pdfStatusPollInterval) {
        clearInterval(pdfStatusPollInterval);
        pdfStatusPollInterval = null;
    }
}

/**
 * Update UI to reflect PDF translating state
 * @param {boolean} translating - Whether translation is in progress
 */
function setPdfTranslatingState(translating) {
    isPdfTranslating = translating;

    // Update translate button state
    if (btnTranslatePdf) {
        btnTranslatePdf.disabled = translating;
        btnTranslatePdf.textContent = translating ? 'â³ ç¿»è¯‘ä¸­...' : 'ğŸš€ å¼€å§‹ç¿»è¯‘';
    }

    // Update clear button state
    if (btnClearPdf) {
        btnClearPdf.disabled = translating;
    }

    // Update progress container visibility
    if (progressContainer) {
        if (translating) {
            progressContainer.classList.add('visible');
        } else {
            progressContainer.classList.remove('visible');
        }
    }
}

/**
 * Cancel PDF translation
 */
async function handleCancelPdfTranslation() {
    try {
        await CancelPDFTranslation();
        stopPdfStatusPolling();
        // ç›´æ¥æ›´æ–° PDF æ¨¡å¼çŠ¶æ€ï¼Œä¸ä½¿ç”¨ updateStatus
        pdfModeStatus = { phase: 'idle', progress: 0, message: 'ç¿»è¯‘å·²å–æ¶ˆ', error: null };
        if (currentMode === 'pdf') {
            applyStatusDisplay(pdfModeStatus);
        }
        setPdfTranslatingState(false);
        showToast('ç¿»è¯‘å·²å–æ¶ˆ', 'info');
    } catch (error) {
        console.error('Cancel PDF translation error:', error);
        showError('å–æ¶ˆç¿»è¯‘å¤±è´¥', 'pdf');
    }
}

/**
 * Set up sync scrolling between the two PDF iframes
 * When one PDF is scrolled, the other follows to the same relative position
 * Validates: Requirements 5.3
 */
function setupPdfSyncScrolling() {
    // We need to wait for iframes to load before setting up scroll listeners
    // The scroll sync is set up when PDFs are loaded via the loadPDF function

    if (pdfLeftIframe) {
        pdfLeftIframe.addEventListener('load', () => {
            setupIframeSyncScroll(pdfLeftIframe, pdfRightIframe, 'left');
        });
    }

    if (pdfRightIframe) {
        pdfRightIframe.addEventListener('load', () => {
            setupIframeSyncScroll(pdfRightIframe, pdfLeftIframe, 'right');
        });
    }
}

/**
 * Set up scroll sync for a specific iframe
 * @param {HTMLIFrameElement} sourceIframe - The iframe that triggers the scroll
 * @param {HTMLIFrameElement} targetIframe - The iframe that should follow
 * @param {string} side - 'left' or 'right' for debugging
 * Validates: Requirements 5.3
 */
function setupIframeSyncScroll(sourceIframe, targetIframe, side) {
    try {
        // Try to access the iframe's content window
        const sourceWindow = sourceIframe.contentWindow;
        if (!sourceWindow) {
            console.warn(`Cannot access ${side} iframe content window`);
            return;
        }

        // Add scroll event listener to the source iframe
        sourceWindow.addEventListener('scroll', () => {
            // Prevent infinite scroll loop
            if (isSyncScrolling) return;

            try {
                const targetWindow = targetIframe.contentWindow;
                if (!targetWindow) return;

                // Get scroll position as percentage
                const sourceDoc = sourceWindow.document.documentElement || sourceWindow.document.body;
                const targetDoc = targetWindow.document.documentElement || targetWindow.document.body;

                if (!sourceDoc || !targetDoc) return;

                const sourceScrollHeight = sourceDoc.scrollHeight - sourceDoc.clientHeight;
                const targetScrollHeight = targetDoc.scrollHeight - targetDoc.clientHeight;

                if (sourceScrollHeight <= 0 || targetScrollHeight <= 0) return;

                // Calculate scroll percentage
                const scrollPercentage = sourceWindow.scrollY / sourceScrollHeight;

                // Apply to target
                isSyncScrolling = true;
                targetWindow.scrollTo({
                    top: scrollPercentage * targetScrollHeight,
                    behavior: 'auto' // Use 'auto' for immediate sync, 'smooth' for animated
                });

                // Reset flag after a short delay
                setTimeout(() => {
                    isSyncScrolling = false;
                }, 50);

            } catch (e) {
                // Cross-origin restrictions may prevent access
                console.debug('Sync scroll error (may be cross-origin):', e.message);
            }
        });

        console.log(`Sync scroll set up for ${side} iframe`);

    } catch (e) {
        // Cross-origin restrictions may prevent access
        console.debug(`Cannot set up sync scroll for ${side} iframe:`, e.message);
    }
}

/**
 * Handle download translated PDF button click
 * Validates: Requirements 5.6
 */
async function handleDownloadTranslatedPdf() {
    if (!translatedPdfPath) {
        showToast('æ²¡æœ‰å¯ä¸‹è½½çš„ç¿»è¯‘ PDF', 'warning');
        return;
    }

    try {
        showToast('æ­£åœ¨å‡†å¤‡ä¸‹è½½...', 'info');

        // Use SaveFileDialog to let user choose save location
        const savePath = await SaveTranslatedPDF(translatedPdfPath);

        if (savePath) {
            showToast('ç¿»è¯‘å PDF å·²ä¿å­˜åˆ°: ' + savePath, 'success');
        } else {
            showToast('å·²å–æ¶ˆä¸‹è½½', 'info');
        }
    } catch (error) {
        console.error('Download translated PDF error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Show the download button for translated PDF
 * @param {string} pdfPath - Path to the translated PDF
 * Validates: Requirements 5.6
 */
function showDownloadTranslatedButton(pdfPath) {
    translatedPdfPath = pdfPath;
    if (btnDownloadTranslated) {
        btnDownloadTranslated.style.display = 'flex';
    }
}

/**
 * Hide the download button for translated PDF
 */
function hideDownloadTranslatedButton() {
    translatedPdfPath = null;
    if (btnDownloadTranslated) {
        btnDownloadTranslated.style.display = 'none';
    }
}

/**
 * Handle arXiv search button click
 * Searches for existing translations on GitHub
 * If not found, validates the arXiv ID and offers to translate
 */
async function handleArxivSearch() {
    const arxivId = arxivSearchInput.value.trim();

    if (!arxivId) {
        showToast('è¯·è¾“å…¥ arXiv ID', 'warning');
        return;
    }

    // Disable button during search
    btnArxivSearch.disabled = true;
    btnArxivSearch.textContent = 'æœç´¢ä¸­...';

    try {
        showToast('æ­£åœ¨ GitHub æœç´¢å·²ç¿»è¯‘è®ºæ–‡...', 'info');

        // Search GitHub
        const searchResult = await SearchGitHubTranslation(arxivId);

        if (!searchResult || !searchResult.found) {
            // Not found on GitHub, validate if it's a valid arXiv ID
            showToast(`æœªæ‰¾åˆ° ${arxivId} çš„ç¿»è¯‘ï¼Œæ­£åœ¨éªŒè¯ arXiv ID...`, 'info');
            
            try {
                // Validate arXiv ID by fetching metadata from arXiv
                const metadata = await GetArxivPaperMetadata(arxivId);
                
                if (metadata && metadata.title) {
                    // Valid arXiv ID, show custom confirm dialog
                    showTranslateConfirmModal(arxivId, metadata);
                } else {
                    showToast(`"${arxivId}" ä¸æ˜¯æœ‰æ•ˆçš„ arXiv ID`, 'warning');
                }
            } catch (validationError) {
                console.error('arXiv validation error:', validationError);
                showToast(`"${arxivId}" ä¸æ˜¯æœ‰æ•ˆçš„ arXiv ID æˆ–æ— æ³•è®¿é—® arXiv`, 'warning');
            }
            return;
        }

        // Found translation! Show download options
        showArxivSearchResultDialog(arxivId, searchResult);

    } catch (error) {
        console.error('GitHub search error:', error);
        showToast('æœç´¢å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        // Re-enable button
        btnArxivSearch.disabled = false;
        btnArxivSearch.innerHTML = '<span class="search-icon">ğŸ”</span>æœç´¢';
    }
}

/**
 * Show translate confirm modal
 * @param {string} arxivId - arXiv ID
 * @param {object} metadata - Paper metadata from arXiv
 */
function showTranslateConfirmModal(arxivId, metadata) {
    // Store the arXiv ID for later use
    pendingTranslateArxivId = arxivId;
    
    // Update modal content
    previewArxivId.textContent = arxivId;
    previewTitle.textContent = metadata.title || '-';
    previewAuthors.textContent = metadata.authors || '-';
    
    // Show modal
    translateConfirmModal.classList.add('visible');
}

/**
 * Close translate confirm modal
 */
function closeTranslateConfirmModal() {
    translateConfirmModal.classList.remove('visible');
    pendingTranslateArxivId = null;
}

/**
 * Confirm translation - start the translation process
 */
function confirmTranslate() {
    if (!pendingTranslateArxivId) {
        closeTranslateConfirmModal();
        return;
    }
    
    // Set the input and close modal
    inputSource.value = pendingTranslateArxivId;
    closeTranslateConfirmModal();
    
    // Start translation
    handleProcess();
}

/**
 * Show search result dialog with download options
 * @param {string} arxivId - arXiv ID
 * @param {object} searchResult - Search result from GitHub
 */
function showArxivSearchResultDialog(arxivId, searchResult) {
    // Store current download data
    currentDownloadData = {
        arxivId: arxivId,
        searchResult: searchResult
    };

    // Set arXiv ID display
    downloadArxivId.textContent = `arXiv: ${arxivId}`;

    // Reset all checkboxes and hide all items
    downloadChineseItem.style.display = 'none';
    downloadBilingualItem.style.display = 'none';
    downloadLatexItem.style.display = 'none';
    downloadChineseCheck.checked = true;
    downloadBilingualCheck.checked = true;
    downloadLatexCheck.checked = true;

    // Show available files
    if (searchResult.chinese_pdf) {
        downloadChineseItem.style.display = 'flex';
        downloadChineseName.textContent = searchResult.chinese_pdf_filename || `${arxivId}_cn.pdf`;
    }

    if (searchResult.bilingual_pdf) {
        downloadBilingualItem.style.display = 'flex';
        downloadBilingualName.textContent = searchResult.bilingual_pdf_filename || `${arxivId}_bilingual.pdf`;
    }

    if (searchResult.latex_zip) {
        downloadLatexItem.style.display = 'flex';
        downloadLatexName.textContent = searchResult.latex_zip_filename || `${arxivId}_latex.zip`;
    }

    // Hide progress
    downloadProgress.style.display = 'none';

    // Show modal
    githubDownloadModal.classList.add('visible');

    // Show success toast
    showToast(`æ‰¾åˆ° ${arxivId} çš„ç¿»è¯‘ï¼`, 'success', 3000);
}

/**
 * Close download modal
 */
function closeDownloadModal() {
    githubDownloadModal.classList.remove('visible');
    currentDownloadData = null;
}

/**
 * Confirm download - download selected files
 */
async function confirmDownload() {
    if (!currentDownloadData) {
        return;
    }

    const { arxivId, searchResult } = currentDownloadData;

    // Collect selected files
    const selectedFiles = [];

    if (downloadChineseItem.style.display !== 'none' && downloadChineseCheck.checked) {
        selectedFiles.push({ type: 'chinese', label: 'ä¸­æ–‡ PDF' });
    }

    if (downloadBilingualItem.style.display !== 'none' && downloadBilingualCheck.checked) {
        selectedFiles.push({ type: 'bilingual', label: 'åŒè¯­å¯¹ç…§ PDF' });
    }

    if (downloadLatexItem.style.display !== 'none' && downloadLatexCheck.checked) {
        selectedFiles.push({ type: 'latex', label: 'LaTeX æºç ' });
    }

    if (selectedFiles.length === 0) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶', 'warning');
        return;
    }

    // Disable buttons and show progress
    btnDownloadConfirm.disabled = true;
    btnDownloadCancel.disabled = true;
    downloadProgress.style.display = 'flex';

    try {
        // Let user select save directory
        const saveDir = await OpenDirectoryDialog();

        if (!saveDir) {
            showToast('å·²å–æ¶ˆä¸‹è½½', 'info');
            closeDownloadModal();
            return;
        }

        let downloadedCount = 0;
        let chinesePdfPath = null;
        let bilingualPdfPath = null;

        // Download each selected file
        for (const file of selectedFiles) {
            try {
                downloadProgressText.textContent = `æ­£åœ¨ä¸‹è½½ ${file.label}...`;
                const savedPath = await DownloadGitHubTranslation(arxivId, file.type, saveDir);

                if (savedPath) {
                    console.log(`Downloaded ${file.label} to:`, savedPath);
                    downloadedCount++;

                    // Remember the PDF paths for loading
                    if (file.type === 'chinese') {
                        chinesePdfPath = savedPath;
                    } else if (file.type === 'bilingual') {
                        bilingualPdfPath = savedPath;
                    }
                }
            } catch (error) {
                console.error(`Failed to download ${file.label}:`, error);
                showToast(`ä¸‹è½½ ${file.label} å¤±è´¥: ${error.message || error}`, 'error');
            }
        }

        if (downloadedCount > 0) {
            showToast(`æˆåŠŸä¸‹è½½ ${downloadedCount} ä¸ªæ–‡ä»¶`, 'success', 5000);

            // Load PDFs in viewer
            // Priority: bilingual PDF on left (original position), Chinese PDF on right
            if (bilingualPdfPath) {
                try {
                    loadPDF('left', bilingualPdfPath);
                    console.log('Loaded bilingual PDF on left:', bilingualPdfPath);
                } catch (e) {
                    console.warn('Could not load bilingual PDF in viewer:', e);
                }
            }
            
            if (chinesePdfPath) {
                try {
                    loadPDF('right', chinesePdfPath);
                    console.log('Loaded Chinese PDF on right:', chinesePdfPath);
                } catch (e) {
                    console.warn('Could not load Chinese PDF in viewer:', e);
                }
            }
        } else {
            showToast('æ²¡æœ‰æ–‡ä»¶è¢«ä¸‹è½½', 'warning');
        }

        // Close modal
        closeDownloadModal();

    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    } finally {
        // Re-enable buttons and hide progress
        btnDownloadConfirm.disabled = false;
        btnDownloadCancel.disabled = false;
        downloadProgress.style.display = 'none';
    }
}

/**
 * Download translation files from GitHub
 * @param {string} arxivId - arXiv ID
 * @param {Array} availableFiles - Array of available file types
 * @param {object} searchResult - Search result
 */
async function downloadGitHubTranslation(arxivId, availableFiles, searchResult) {
    try {
        // Let user select save directory
        const saveDir = await OpenDirectoryDialog();

        if (!saveDir) {
            showToast('å·²å–æ¶ˆä¸‹è½½', 'info');
            return;
        }

        showToast('å¼€å§‹ä¸‹è½½...', 'info');
        let downloadedCount = 0;
        let chinesePdfFilename = null;

        // Download each available file
        for (const file of availableFiles) {
            try {
                showToast(`æ­£åœ¨ä¸‹è½½ ${file.label}...`, 'info');
                const savedPath = await DownloadGitHubTranslation(arxivId, file.type, saveDir);

                if (savedPath) {
                    console.log(`Downloaded ${file.label} to:`, savedPath);
                    downloadedCount++;

                    // Remember the Chinese PDF filename for loading
                    if (file.type === 'chinese') {
                        // Extract filename from full path
                        const pathParts = savedPath.split('\\');
                        chinesePdfFilename = pathParts[pathParts.length - 1];
                    }
                }
            } catch (error) {
                console.error(`Failed to download ${file.label}:`, error);
                showToast(`ä¸‹è½½ ${file.label} å¤±è´¥: ${error.message || error}`, 'error');
            }
        }

        if (downloadedCount > 0) {
            showToast(`æˆåŠŸä¸‹è½½ ${downloadedCount} ä¸ªæ–‡ä»¶åˆ° ${saveDir}`, 'success', 5000);

            // Optionally, load PDFs if they were downloaded
            if (chinesePdfFilename) {
                const chinesePdfPath = `${saveDir}\\${chinesePdfFilename}`;
                try {
                    // Try to load the Chinese PDF in the viewer
                    loadPDF('right', chinesePdfPath);
                } catch (e) {
                    console.warn('Could not load downloaded PDF in viewer:', e);
                }
            }
        } else {
            showToast('æ²¡æœ‰æ–‡ä»¶è¢«ä¸‹è½½', 'warning');
        }

    } catch (error) {
        console.error('Download error:', error);
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Open browse library modal and load recent translations
 */
async function openBrowseLibrary() {
    // Show modal
    browseLibraryModal.classList.add('visible');

    // Show loading state
    libraryLoading.style.display = 'block';
    libraryContent.style.display = 'none';
    libraryEmpty.style.display = 'none';

    try {
        // Load categories if not loaded
        if (paperCategories.length === 0) {
            paperCategories = await GetPaperCategories();
        }
        
        // Initialize category filter tags
        initCategoryFilterTags();
        
        // Load page size from settings
        const settings = await GetSettings();
        console.log('Loaded settings:', settings);
        console.log('Library page size from settings:', settings?.library_page_size);
        
        if (settings && settings.library_page_size > 0) {
            pageSize = settings.library_page_size;
            console.log('Using page size from settings:', pageSize);
        } else {
            console.log('Using default page size:', pageSize);
        }

        // Fetch all translations from GitHub (up to 1000)
        const papers = await ListRecentGitHubTranslations(1000);

        if (!papers || papers.length === 0) {
            libraryLoading.style.display = 'none';
            libraryEmpty.style.display = 'block';
            return;
        }

        // Store all papers
        allPapers = papers;
        
        // Reset category filter
        selectedCategories = ['all'];
        updateCategoryFilterUI();
        
        // Apply filter and render (sync for 'all' category)
        await applyLibraryFilter();

        // Show content
        libraryLoading.style.display = 'none';
        libraryContent.style.display = 'flex';

    } catch (error) {
        console.error('Failed to load library:', error);
        showToast('åŠ è½½å…±äº«åº“å¤±è´¥: ' + (error.message || error), 'error');
        libraryLoading.style.display = 'none';
        libraryEmpty.style.display = 'block';
    }
}

/**
 * Initialize category filter tags
 */
function initCategoryFilterTags() {
    categoryFilterTags.innerHTML = '';
    
    // Add "All" tag
    const allTag = document.createElement('span');
    allTag.className = 'category-tag selected';
    allTag.dataset.category = 'all';
    allTag.textContent = 'å…¨éƒ¨';
    allTag.onclick = () => toggleCategoryFilter('all');
    categoryFilterTags.appendChild(allTag);
    
    // Add category tags
    for (const cat of paperCategories) {
        const tag = document.createElement('span');
        tag.className = 'category-tag';
        tag.dataset.category = cat.id;
        tag.textContent = cat.name;
        tag.title = cat.description;
        tag.onclick = () => toggleCategoryFilter(cat.id);
        categoryFilterTags.appendChild(tag);
    }
}

/**
 * Toggle category filter selection
 */
function toggleCategoryFilter(categoryId) {
    if (categoryId === 'all') {
        // If clicking "all", clear other selections
        selectedCategories = ['all'];
    } else {
        // Remove "all" if it's selected
        const allIndex = selectedCategories.indexOf('all');
        if (allIndex > -1) {
            selectedCategories.splice(allIndex, 1);
        }
        
        // Toggle this category
        const index = selectedCategories.indexOf(categoryId);
        if (index > -1) {
            selectedCategories.splice(index, 1);
        } else {
            selectedCategories.push(categoryId);
        }
        
        // If no categories selected, select "all"
        if (selectedCategories.length === 0) {
            selectedCategories = ['all'];
        }
    }
    
    updateCategoryFilterUI();
    applyLibraryFilter();
}

/**
 * Update category filter UI to reflect current selection
 */
function updateCategoryFilterUI() {
    const tags = categoryFilterTags.querySelectorAll('.category-tag');
    tags.forEach(tag => {
        const catId = tag.dataset.category;
        if (selectedCategories.includes(catId)) {
            tag.classList.add('selected');
        } else {
            tag.classList.remove('selected');
        }
    });
}

/**
 * Extract category ID from filename
 * Format: arxivid_categoryid_cn.pdf or arxivid_categoryid_bilingual.pdf
 */
function extractCategoryFromFilename(filename) {
    if (!filename) return null;
    
    // Match pattern: something_categoryid_cn.pdf or something_categoryid_bilingual.pdf
    const match = filename.match(/_([a-z0-9]+)_(cn|bilingual)\.pdf$/i);
    if (match) {
        const potentialCatId = match[1];
        // Check if it's a valid category
        if (paperCategories.some(c => c.id === potentialCatId)) {
            return potentialCatId;
        }
    }
    return null;
}

/**
 * Apply library filter and update display
 * When categories are selected (not "all"), fetches from backend API
 */
async function applyLibraryFilter() {
    // If "all" is selected, use the cached allPapers
    if (selectedCategories.includes('all')) {
        window._filteredPapers = allPapers;
        currentPage = 1;
        totalPages = Math.ceil(allPapers.length / pageSize) || 1;
        totalPapersSpan.textContent = allPapers.length;
        renderCurrentPageFiltered();
        return;
    }
    
    // Show loading state
    libraryLoading.style.display = 'block';
    libraryContent.style.display = 'none';
    
    try {
        // Fetch papers filtered by categories from backend
        const filteredPapers = await ListGitHubTranslationsByCategories(selectedCategories, 1000);
        
        // Update pagination
        currentPage = 1;
        totalPages = Math.ceil(filteredPapers.length / pageSize) || 1;
        
        // Update total papers count
        totalPapersSpan.textContent = filteredPapers.length;
        
        // Store filtered papers for rendering
        window._filteredPapers = filteredPapers;
        
        // Hide loading, show content
        libraryLoading.style.display = 'none';
        
        if (filteredPapers.length === 0) {
            libraryEmpty.style.display = 'block';
            libraryContent.style.display = 'none';
        } else {
            libraryEmpty.style.display = 'none';
            libraryContent.style.display = 'flex';
            renderCurrentPageFiltered();
        }
    } catch (error) {
        console.error('Failed to filter library by categories:', error);
        showToast('ç­›é€‰å¤±è´¥: ' + (error.message || error), 'error');
        libraryLoading.style.display = 'none';
        libraryContent.style.display = 'flex';
        // Fall back to local filtering
        const filteredPapers = allPapers.filter(paper => {
            const catId = extractCategoryFromFilename(paper.chinese_pdf) || 
                          extractCategoryFromFilename(paper.bilingual_pdf);
            return catId && selectedCategories.includes(catId);
        });
        window._filteredPapers = filteredPapers;
        currentPage = 1;
        totalPages = Math.ceil(filteredPapers.length / pageSize) || 1;
        totalPapersSpan.textContent = filteredPapers.length;
        renderCurrentPageFiltered();
    }
}

/**
 * Render current page of filtered papers
 */
function renderCurrentPageFiltered() {
    const filteredPapers = window._filteredPapers || allPapers;
    
    // Clear existing list
    libraryList.innerHTML = '';

    // Calculate start and end indices
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, filteredPapers.length);

    // Get papers for current page
    const pagePapers = filteredPapers.slice(startIndex, endIndex);

    // Render each paper
    for (const paper of pagePapers) {
        renderLibraryPaperItem(paper);
    }

    // Update pagination UI
    updatePaginationUI();

    // Scroll to top of list
    libraryList.scrollTop = 0;
}

/**
 * Render current page of papers
 */
function renderCurrentPage() {
    // Use filtered rendering
    renderCurrentPageFiltered();
}

/**
 * Update pagination UI
 */
function updatePaginationUI() {
    // Update page numbers
    currentPageSpan.textContent = currentPage;
    totalPagesSpan.textContent = totalPages;

    // Update button states
    btnFirstPage.disabled = currentPage === 1;
    btnPrevPage.disabled = currentPage === 1;
    btnNextPage.disabled = currentPage === totalPages;
    btnLastPage.disabled = currentPage === totalPages;
}

/**
 * Go to specific page
 * @param {number} page - Page number (1-based)
 */
function goToPage(page) {
    if (page < 1 || page > totalPages || page === currentPage) {
        return;
    }

    currentPage = page;
    renderCurrentPage();
}

/**
 * Close browse library modal
 */
function closeBrowseLibrary() {
    browseLibraryModal.classList.remove('visible');
}

/**
 * Render a library paper item
 * @param {object} paper - Paper info from GitHub
 */
function renderLibraryPaperItem(paper) {
    const item = document.createElement('div');
    item.className = 'library-paper-item';
    item.dataset.arxivId = paper.arxiv_id;

    // Create paper header with arXiv ID
    const header = document.createElement('div');
    header.className = 'library-paper-header';

    const arxivId = document.createElement('span');
    arxivId.className = 'library-paper-arxiv';
    arxivId.textContent = paper.arxiv_id;
    header.appendChild(arxivId);

    item.appendChild(header);

    // Create title placeholder
    const title = document.createElement('div');
    title.className = 'library-paper-title';
    title.textContent = 'åŠ è½½ä¸­...';
    item.appendChild(title);

    // Create file badges
    const filesDiv = document.createElement('div');
    filesDiv.className = 'library-paper-files';

    if (paper.has_chinese) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“„</span> ä¸­æ–‡PDF';
        filesDiv.appendChild(badge);
    }

    if (paper.has_bilingual) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“‘</span> åŒè¯­PDF';
        filesDiv.appendChild(badge);
    }

    if (paper.has_latex) {
        const badge = document.createElement('span');
        badge.className = 'library-file-badge';
        badge.innerHTML = '<span>ğŸ“¦</span> LaTeX';
        filesDiv.appendChild(badge);
    }

    item.appendChild(filesDiv);

    // No abstract tooltip - removed to avoid interfering with operations

    // Add click handler to show action menu
    item.addEventListener('click', () => {
        handleLibraryPaperClick(paper);
    });

    // Add to list
    libraryList.appendChild(item);

    // Fetch metadata asynchronously (title only, no abstract)
    fetchPaperMetadata(paper.arxiv_id, item, title);
}

/**
 * Fetch paper metadata from arXiv and update UI
 * Uses cache to avoid repeated API calls
 * Cache is persisted to localStorage for faster loading on next startup
 * @param {string} arxivId - arXiv ID
 * @param {HTMLElement} item - Paper item element
 * @param {HTMLElement} titleElement - Title element
 */
async function fetchPaperMetadata(arxivId, item, titleElement) {
    // Check cache first
    if (paperMetadataCache.has(arxivId)) {
        const cached = paperMetadataCache.get(arxivId);
        titleElement.textContent = cached.title || arxivId;
        return;
    }

    try {
        const metadata = await GetArxivPaperMetadata(arxivId);

        if (metadata && metadata.title) {
            // Cache only the title (no abstract to avoid tooltip issues)
            paperMetadataCache.set(arxivId, {
                title: metadata.title
            });

            // Save cache to localStorage
            saveMetadataCache();

            // Update title
            titleElement.textContent = metadata.title;
        } else {
            // Cache empty result to avoid repeated failed requests
            paperMetadataCache.set(arxivId, { title: arxivId });
            saveMetadataCache();
            titleElement.textContent = arxivId;
        }
    } catch (error) {
        console.warn(`Failed to fetch metadata for ${arxivId}:`, error);
        // Cache the failure to avoid repeated requests
        paperMetadataCache.set(arxivId, { title: arxivId });
        saveMetadataCache();
        titleElement.textContent = arxivId; // Fallback to arXiv ID
    }
}

/**
 * Handle library paper item click - show action menu
 * @param {object} paper - Paper info
 */
async function handleLibraryPaperClick(paper) {
    // Close library modal
    closeBrowseLibrary();

    // Search for the paper to get full details
    try {
        showToast(`æ­£åœ¨åŠ è½½ ${paper.arxiv_id} çš„è¯¦ç»†ä¿¡æ¯...`, 'info');
        const searchResult = await SearchGitHubTranslation(paper.arxiv_id);

        if (searchResult && searchResult.found) {
            // Show action menu: Download or Read
            showPaperActionMenu(paper.arxiv_id, searchResult);
        } else {
            showToast(`æœªæ‰¾åˆ° ${paper.arxiv_id} çš„ç¿»è¯‘`, 'warning');
        }
    } catch (error) {
        console.error('Failed to load paper details:', error);
        showToast('åŠ è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Show paper action menu (Download or Read)
 * @param {string} arxivId - arXiv ID
 * @param {object} searchResult - Search result from GitHub
 */
function showPaperActionMenu(arxivId, searchResult) {
    const actions = [
        {
            label: 'ğŸ“¥ ä¸‹è½½',
            description: 'ä¸‹è½½åˆ°æŒ‡å®šç›®å½•',
            action: () => {
                showArxivSearchResultDialog(arxivId, searchResult);
            }
        },
        {
            label: 'ğŸ“– é˜…è¯»',
            description: 'ä¸‹è½½å¹¶è‡ªåŠ¨æ‰“å¼€',
            action: async () => {
                await downloadAndOpenPaper(arxivId, searchResult);
            }
        }
    ];

    showActionMenu('é€‰æ‹©æ“ä½œ', actions);
}

/**
 * Download paper to cache and open it
 * @param {string} arxivId - arXiv ID
 * @param {object} searchResult - Search result from GitHub
 */
async function downloadAndOpenPaper(arxivId, searchResult) {
    try {
        // Show progress in status bar
        updateStatus('downloading', 0, 'æ­£åœ¨ä¸‹è½½è®ºæ–‡...');
        
        // Determine which files to download (prefer bilingual, then chinese)
        const filesToDownload = [];
        
        if (searchResult.bilingual_pdf) {
            filesToDownload.push({ type: 'bilingual', label: 'åŒè¯­å¯¹ç…§ PDF' });
        }
        if (searchResult.chinese_pdf) {
            filesToDownload.push({ type: 'chinese', label: 'ä¸­æ–‡ PDF' });
        }
        
        if (filesToDownload.length === 0) {
            showToast('æ²¡æœ‰å¯ç”¨çš„ PDF æ–‡ä»¶', 'warning');
            updateStatus('idle', 0, '');
            return;
        }

        // Download to cache directory (don't open in external viewer)
        const result = await DownloadAndOpenGitHubTranslation(arxivId, 'bilingual', false);
        
        if (result && result.success) {
            updateStatus('idle', 0, '');
            showToast('å·²æ‰“å¼€è®ºæ–‡', 'success');
            
            // Load PDFs in viewer if paths are provided
            if (result.bilingual_path) {
                loadPDF('left', result.bilingual_path);
            }
            if (result.chinese_path) {
                loadPDF('right', result.chinese_path);
            }
        } else {
            updateStatus('idle', 0, '');
            showToast('ä¸‹è½½å¤±è´¥', 'error');
        }
    } catch (error) {
        console.error('Failed to download and open paper:', error);
        updateStatus('idle', 0, '');
        showToast('ä¸‹è½½å¤±è´¥: ' + (error.message || error), 'error');
    }
}

/**
 * Show action menu dialog
 * @param {string} title - Menu title
 * @param {Array} actions - Array of action objects with label, description, and action function
 */
function showActionMenu(title, actions) {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
    
    // Create menu container
    const menu = document.createElement('div');
    menu.style.cssText = 'background: white; border-radius: 8px; padding: 20px; min-width: 300px; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
    
    // Add title
    const titleEl = document.createElement('h3');
    titleEl.textContent = title;
    titleEl.style.cssText = 'margin: 0 0 15px 0; font-size: 18px; color: #333;';
    menu.appendChild(titleEl);
    
    // Add action buttons
    actions.forEach(action => {
        const btn = document.createElement('button');
        btn.style.cssText = 'width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; text-align: left; transition: all 0.2s;';
        
        const label = document.createElement('div');
        label.textContent = action.label;
        label.style.cssText = 'font-size: 16px; font-weight: 500; color: #333; margin-bottom: 4px;';
        
        const desc = document.createElement('div');
        desc.textContent = action.description;
        desc.style.cssText = 'font-size: 13px; color: #666;';
        
        btn.appendChild(label);
        btn.appendChild(desc);
        
        btn.addEventListener('mouseenter', () => {
            btn.style.background = '#f5f5f5';
            btn.style.borderColor = '#4CAF50';
        });
        
        btn.addEventListener('mouseleave', () => {
            btn.style.background = 'white';
            btn.style.borderColor = '#ddd';
        });
        
        btn.addEventListener('click', () => {
            document.body.removeChild(overlay);
            action.action();
        });
        
        menu.appendChild(btn);
    });
    
    // Add cancel button
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'å–æ¶ˆ';
    cancelBtn.style.cssText = 'width: 100%; padding: 10px; margin-top: 12px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; color: #666;';
    cancelBtn.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });
    menu.appendChild(cancelBtn);
    
    overlay.appendChild(menu);
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    document.body.appendChild(overlay);
}


// Export functions for testing
export {
    handleProcess,
    handleCancel,
    handleBrowse,
    updateStatus,
    loadPDF,
    setProcessingState,
    openSettings,
    closeSettings,
    saveSettings,
    testConnection,
    performStartupCheck,
    showStartupCheckModal,
    closeStartupCheckModal,
    // PDF Translation exports
    switchMode,
    handleSelectPdf,
    handleTranslatePdf,
    clearSelectedPdf,
    handleCancelPdfTranslation,
    setPdfTranslatingState,
    // Sync scrolling and download exports
    setupPdfSyncScrolling,
    handleDownloadTranslatedPdf,
    showDownloadTranslatedButton,
    hideDownloadTranslatedButton
};
